<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Map集合]]></title>
    <url>%2F2018%2F11%2F12%2FMap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Map集合：Hashtable:底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。HashMap:底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。代替了Hashtable。TreeMap:底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。 Map集合存储和Collection有着很大不同：Collection一次存一个元素；Map一次存一对元素。Collection是单列集合；Map是双列集合。Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应（映射）关系。特点：要保证map集合中键的唯一性。 1.添加。 put(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。void putAll(Map);2.删除。void clear()：清空value remove(key) ：删除指定键。3.判断。boolean isEmpty()：boolean containsKey(key)：是否包含keyboolean containsValue(value) ：是否包含value4.取出。int size()：返回长度value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。Collection values()：获取map集合中的所有的值。5.想要获取map中的所有元素：原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。 把map集合转成set的方法： Set keySet(); Set entrySet();//取的是键和值的映射关系。 Entry就是Map接口中的内部接口；为什么要定义在map内部呢?entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。 遍历Map集合的四种方法 public static void main(String[] args){ Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(“1”,”value1”); map.put(“2”,”value2”); map.put(“3”,”value3”); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value: &quot;); for(String key : map.keySet()){ System.out.println(&quot;key=&quot; + key + &quot;and value&quot; + map.get(key)); } } //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value: &quot;); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = map,entrySet().iterator(); while(it.hasNext()){ Map.Entry&lt;String,String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot;and value = &quot; + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){ System.out.println(&quot;key= &quot; + entry.getKty() + &quot;and value = &quot; + entey.getValue()); } //第四种 System.out.println(&quot;通过Map.values()遍历所有的value,但布不能遍历key&quot;); for(String v : map.values()){ System.out.println(&quot;value= &quot; + v); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set接口]]></title>
    <url>%2F2018%2F11%2F12%2FSet%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种。迭代器。HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；HashSet集合保证元素唯一性：通过元素的hashCode方法，和Equals方法完成的。当元素的hashCode 值相同时，才继续判断元素的equals是否为true。如果为true，那么视为相同元素，不存。如果为false，那么存储。如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。LinkedHashSet:有序，hashSet的子类。TreeSet:对Set集合中元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。 哈希表的原理：1.对对象元素中的关键字（对象中的特有数据），进行哈希算法的运算，并得出一个具体的算法值，这个值称为哈希值。2.哈希值就是这个元素的位置。3.如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础+1顺延。4.存储哈希值的结构，我们称为哈希表。5.存储哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。 对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。 TreeSet:用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。如果元素不具备比较性，在运行时会发生ClassCastException异常。所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。 注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。 TreeSet集合排序有两种方式，Comparable和Comparator区别：1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。第二种方式较为灵活。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口]]></title>
    <url>%2F2018%2F11%2F12%2FList%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习LIst体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最在的特点。 List:有序（元素存入集合的顺序和取出的顺序一致），元素都有索引。元素可以重复。 ArrayList：底层的数据结构是数组，线程不同步，ArrayList替代了Vector，查询元素的速度非常快。 LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。 Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都很慢。 1.添加：add(index,element) ：在指定的索引位插入元素。addAll(index,collection) ：在指定的索引位插入一堆元素。2.删除：remove(index) ：删除指定索引位的元素。 返回被删的元素。3.获取：Object get(index) ：通过索引获取指定元素。int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回-1；所以，通过-1，可以判断一个元素是否存在。int lastIndexOf(Object o) ：反向索引指定元素的位置。List subList(start,end) ：获取子列表。4.修改：Object set(index,element) ：对指定索引位进行元素的修改。5.获取所有元素：ListIterator listIterator()：list集合特有的迭代器。 List集合支持对元素的增、删、改、查。List集合因为有下标有了自己的获取元素的方式：遍历。 for(int x=0; x&lt;list.size(); x++){ sop(&quot;get:&quot;+list.get(x)); } 注意：在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。导致的原因是：集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。如何解决呢？既然是在迭代中对元素进行操作，找迭代器的方法最为合适。可是Iterator中只有hasNext,next,remove方法。通过查询它的子接口，ListIerator，发现该列表迭代器接口具备了对元素的增、删、改、查的动作。 ListIterator是List集合特有的迭代器。 ListIterator it = list.listIterator;//取代Iterator it = list.iterator; 返回值 方法 void add(E e)将指定的元素插入列表（可选操作）。 boolean hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。 boolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。 E next() 返回列表中的下一个元素。 int nextIndex() 返回对 next 的后续调用所返回元素的索引。 E previous() 返回列表中的前一个元素。 int previousIndex() 返回对 previous 的后续调用所返回元素的索引。 void remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。 void set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。 可变长度数组的原理：当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。ArratList：构造一个初始容量为10的空列表。是按照原数组的50%延长（jdk1.8之前为50% + 1）。Vector:是按照原数组的100%延长。 注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。 LinkedList：的特有方法。addFirst();addLast();在jdk1.6以后。offerFirst();offerLast(); getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;getLast();在jdk1.6以后。peekFirst();获取链表中的第一个元素。如果链表为空，返回null。peekLast(); removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementExceptionremoveLast();在jdk1.6以后。pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。pollLast();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator接口]]></title>
    <url>%2F2018%2F11%2F12%2FIterator%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[迭代器：是一个接口。作用：用于取集合中的元素。 返回值 方法 boolean hasNext()如果仍有元素可以迭代，则返回true。 E next()返回迭代的下一个元素。 void remove()从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作） 每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。也就是说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。 Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是什么不重要。这对象肯定符合一个规则Iterator接口。 public static void main(String[] args){ Collection coll = new ArrayList(); coll.add(&quot;abc0&quot;); coll.add(&quot;abc1&quot;); coll.add(&quot;abc2&quot;); } //遍历 Iterator it = coll.iterator(); while(it.hasNext()){ System.out.println(it.next()); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection接口]]></title>
    <url>%2F2018%2F11%2F12%2FCollection%2F</url>
    <content type="text"><![CDATA[Collection:List:有序（元素存入集合的顺序和取出的顺序一致），元素都有索引。元素可以重复。Set:无序（存入和取出顺序有可能不一致），不可以存储重复元素。必须保证元素唯一性。1.添加：add(object)：添加一个元素addAll(Collection) ：添加一个集合中的所有元素。2.删除：clear()：将集合中的元素全删除，清空集合。remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。3.判断：boolean contains(obj) ：集合中是否包含指定元素。boolean containsAll(Collection) ：集合中是否包含指定的多个元素。boolean isEmpty()：集合中是否有元素。4.获取：int size()：集合中有几个元素。5.取交集：boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。6.获取集合中所有元素：Iterator iterator()：迭代器7.将集合变成数组：toArray(); 使用集合的技巧：看到Arry就是数组结构，有角标，查询速度很快。看到link就是链表结构，增删速度快，而且有特有方法。addFirst;addLast;removeFirst();removeLast();getFirst();getLast();看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构中的元素必须覆盖hashCode,equals方法。看到tree就是二叉树，就要想到排序，就要用到比较。比较的两种方式：一个是Comparable:覆盖compareTo方法；一个是Comparator:覆盖compare方法。LinkedHashSet,LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。 集合什么时候用？当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。 保证唯一，就用Set。不保证唯一，就用List。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[doGet()与doPost()]]></title>
    <url>%2F2018%2F11%2F10%2FdoGet-%E4%B8%8EdoPost%2F</url>
    <content type="text"><![CDATA[Get与Post都是向服务器传数据在Servlet中doPost方法里还调用了doGet方法(doGet(request,response))所以在创建Servlet时可以不要doPost方法，通常情况下二者没区别。建议：1.涉及传密用Post数据提交。2.数据查询用Get方式；数据添加、修改或删除时，用Post方式。使用表单时，如果不指定method，默认为Get方式。区别： 1.生成方式Get有三种：（1）直接在URL地址栏中输入（2）网页中的超链接（3）form中method为get或不设置methodPost一种：form中method为post 2.数据传输方式Get方式：表单数据存放在URL地址后面。所有Get方式提交时HTTP中没有消息体Post方式：表单数据存放在HTTP协议的消息体中以实体方式传送到服务器。 3.服务器获取数据方式Get方式：服务器采用request.QueryString来获取变量的值。Post方式：服务器采用request.Form来获取数据。 4.传送的数据量Get方式：数据量长度有限制，一般不超过2kb,因为是参数传递，且在地址中，故数据量有限制。Post方式：适合大规模的数据传送，因为是以实体的方式传送的。 5.安全性Get方式：安全性差，因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。Post方式：安全性较高，因为Post方式提交数据时采用的HTTPpost机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到action所指的URL中，用户是看不见的。 6.在用户刷新时Get方式：不会有任何提示Post方式：会弹出提示框，问用户是否重新提交。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet生命周期和创建方式]]></title>
    <url>%2F2018%2F11%2F10%2FServlet-%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Servletservlet是运行在Web服务器中的小型Java程序（即，服务器端的小应用程序）。servlet通常通过Http（超文本传输协议）接受和响应来自Web客户端的请求。这个servlet不用new，就是一个Java类，可以直接使用，用来处理请求响应的。写一个Java类实现servlet接口。重写未实现的方法。其实最关键的一个就是service()方法。 Servlet的生命周期（重要）四个过程1.加载和实例化当Servlet容器启动或客户端发送一个请求时，Serlvet容器会查找内存中是否存在该Serlvet实例，若存在，则直接读取该实例响应请求；如果不存在就创建一个Servlet实例。2.init初始化实例化后，Servlet将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）3.service服务，每次被访问都会被调用初始化后，Servlet处于能响应请求的就绪状态。当接受到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求，转调不同的doXXX方法。4.destroy销毁当Servlet容器关闭时，Servlet实例也随时销毁，其间，Servlet容器会调用Servlet的destroy()方法去判断该Servlet是否应当被释放（或回收资源） Servlet执行过程：1.先写一个类实现Servlet接口。2.然后现在web.xml中配置上面第二步中：创建一个servlet实例 &lt;!-- 创建一个Servlet实例 --&gt; &lt;servlet&gt; &lt;!--3.servlet的内部名称--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--4.servlet的类全名：包名加简单类名--&gt; &lt;servlet-class&gt;com.itheima.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; 这个标签其实就是new这个servlet类，底层代码其实就是classforName，因为Tomcat功能可以解析xml，所以可以这么写servlet-mapping: &lt;!-- 给Servlet提供（映射）一个可供客户端访问的URL --&gt; &lt;servlet-mapping&gt; &lt;!--2.servlet的映射内部名称，通过他可以找到上面的servlet的内部名称--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--1.请求servlet的映射路径--&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 一定记得加一个/，否则就是访问localhost:8080/demo1，而不是localhost:8080/项目名/demo1，通过这个映射地址找到servlet类。 原理解释： 三步走：1.客户端首先通过地址访问demo下的北荣，tomcat会找到对应的项目。2.然后会通过web.xml找到url-pattern下为 /demo的标签，然后找到兄弟标签servlet-name对应的servletDemo。3.最后找到对应的servlet类，之后就会调用该类下的service()方法。 第一种创建方式：写一个类实现servlet接口，重写5个方法。 import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 第二种创建方式：继承javax.servlet.GenericServlet类（适配器模式），实现service方法 import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; public class ServletDemo2 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } } 第三种创建方式（最常用）：使用方法：创建一个类然后继承HttpServlet类，重写doGet，doPost方法。 import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); } } 对于错误信息： HTTP Status 405 - HTTP method GET is not supported by this URL type Status report message HTTP method GET is not supported by this URL description The specified HTTP method is not allowed for the requested resource. Apache Tomcat/7.0.75 原因是在覆盖doPost或者doGet的时候忘记去掉super.doGet或者super.doPost了，去掉就好了。 补充三种创建方式的关系： Servlet –&gt; GenericServlet –&gt; HttpServlet（继承HttpServlet）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目经验]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[项目名称： 飞机大战项目简介： 该项目主要采用面向对象的思想，通过构建对象实现接口和多线程实时刷新，在JFrame窗体中利用Graphics类在画板上生成和移除，实现了飞机大战的基本玩法，加入了血量，火力升级，积分，敌方飞机的不同轨道以及BOSS独特的攻击模式。 项目名称： 员工管理系统项目简介： 该项目主要采用了Spring,SpringMVC,Mybatis框架和MySQL,JQuery,AJax等为主要技术。项目主要功能为注册，登录进入管理界面，可以对部门、员工进行增删改查，结果利用Page分页显示，利用session记录登录状态，利用cookie实现免登录，验证码利用Graphics生成并添加定时器，提供模糊查找的功能。 项目名称： 饿了么外卖（移动端）项目简介： 该项目采用前后端分离开发，前端主要使用Vue+nginx+node.js。后端主要使用SpringBoot。前端部分展示商家信息，客户评价和商品信息，利用nginx反向代理到本地tomcat服务器。Vue的组件化开发,router实现界面内跳转，整体布局使用弹性布局，利用better-scroll插件实现滚动和联动。后端部分：提供了买家订单，订单详情，商品信息和商品类目的管理。利用SpringBoot生成一个web项目，进行yml的配置，根据Api文档考虑业务逻辑和代码逻辑。例如，买家订单id不能重复，利用系统时间加5位随机数。商品信息和商品类目的展示添加分页，增加和修改可以判断是否有id利用一个页面实现，捕捉异常跳转失败页面，时间的输出格式等。 项目名称： 搭建个人博客项目简述： 该项目是个人利用课余时间摸索搭建而成的个人博客，主要采用node.js,hexo,github为主要技术。项目主要功能为可以上传分享一些文章，展示个人简介，文章归档，标签，分类，归档，站内搜索，评论等功能。并使用个人域名解析实现个性域名。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目简单叙述]]></title>
    <url>%2F2018%2F11%2F08%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[项目名： 仿饿了么项目 项目描述： 采用前后端分离开发，前端主要使用Vue+nginx+node.js。后端主要使用SpringBoot。前端部分：展示了商家信息，客户评价和商品信息。利用nginx反向代理到本地tomcat。后端部分：提供了买家订单，订单详情，商品信息和商品类目的管理。 项目实现过程：前端部分：Vue的组件化开发，router路由实现界面跳转，页面布局使用弹性布局。商家信息的背景图片模糊化，公告弹层利用v-show，定位和层级。客户评价获取后台数据。商品信息较为复杂，利用better-scroll插件实现滚动效果和联动。在使用v-for遍历数据时加入index与计算属性绑定实现点击高亮效果。购物车根据商品数量与价格判断是否显示与滚动效果。后端部分：利用springboot生成一个项目，进行yml的配置，根据Api文档考虑业务逻辑和代码逻辑。买家订单id不能重复利用系统时间加5位随机数，根据订单状态判断是否需要取消，商品信息和商品类目的展示添加分页，增加和修改可以判断是否有id利用一个页面实现，捕捉异常跳转失败页面，时间的输出格式等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>nginx</tag>
        <tag>node</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math ceil(),floor(),round()方法]]></title>
    <url>%2F2018%2F11%2F07%2FMath-ceil-floor-round-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Math.ceil()对一个数进行向上取整(个人理解向大转)使用方法 Math.ceil(x); 返回值：返回大于或等于x，并且与之最接近的整数。正数则把小数“入”，负数则把小数“舍”。例如： Math.ceil(1.2); //输出2 Math.ceil(1.8); //输出2 Math.ceil(-1.2); //输出-1 Math.ceil(-1.8); //输出-1 Math.floor()对一个数进行向下取整（个人理解向小转）使用方法 Math.floor(x); 返回值：返回小于或等于x并且与之最为接近的整数。正数则把小数“舍”，负数则把小数“入”。例如： Math.floor(1.2); //输出1 Math.floor(1.8); //输出1 Math.floor(-1.2); //输出-2 Math.floor(-1.8); //输出-2 Math.round()四舍五入取整使用方法 Math.round(x); 返回值：与x最接近的整数。 Math.floor(1.2); //输出1 Math.floor(1.8); //输出2 Math.floor(-1.2); //输出-1 Math.floor(-1.8); //输出-2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven远程仓库]]></title>
    <url>%2F2018%2F11%2F05%2FMaven%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Maven配置中央仓库maven作为一个项目管理工具确实为我们提供了很大的方便，但是在国内这个网络下对我们就不是很友好了，阿里云和华为云都为我们提供了中央仓库，个人推荐华为云，因为在学习SpringBoot时，出现了jar包缺少依赖的问题，而华为云没有。 本地仓库在这里先提一下修改本地仓库的储存路径，默认情况下maven会在用户目录下创建.m2/repository/的仓库目录，但一般情况下，我们不希望在C盘有过多的文件，我们需要在找到 \apache-maven\conf\settings.xml 打开，找到settings标签 &lt;settings&gt; //将默认仓库注释掉，添加自定义仓库路径 &lt;localRepository&gt;D:\Program Files\JAVA\mavenRepository&lt;/localRepository&gt; &lt;/settings&gt; 这样maven下载jar包的时候就会下载到自定义路径中 阿里云中央仓库修改远程仓库为阿里云中央仓库 还是在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 这样就配置成功了 华为云中央仓库修改远程仓库为华为云中央仓库 操作差不多，需要多加一步，先在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt; &lt;/mirror&gt; 还需要在servers标签中添加一个server &lt;servers&gt; &lt;server&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;username&gt;anonymous&lt;/username&gt; &lt;password&gt;devcloud&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 开始体验飞一般的下载速度吧！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的基本使用]]></title>
    <url>%2F2018%2F11%2F03%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git简介Git是目前世界上最先进的分布式版本控制系统。Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。 Git下载https://git-scm.com/downloads一路next就可以在桌面右键出现Git Bash here和Git GUI here就说明成功了 Git基本使用配置用户名，邮箱 git config –global user.email “你的邮箱”git config –global user.name “你的用户名” 这个是用来配置本地仓库的，可以随意填写 创建一个本地版本仓库接下来我们创建第一个仓库1.创建一个空白文件夹，目录不包含中文，右键Git Bash here，输入 git init 我们可以看到当前目录出现了一个.git目录（这是个默认隐藏的文件夹）2.创建一个hellogit.txt文件3.添加文件到本地仓库 git add hellogit.txtgit commit -m “文件描述” 这样我们就把这个文件添加到了本地仓库4.把文件中加一些文字，执行以下命令 git status 查看仓库当前状态，提示有文件被修改了，需要再次执行git add和git commit 版本回退1.打印日志 git log //查看提交历史git reflog //查看命令历史git reset –hard “” //填写你想回退的版本的id 2.查看当前状态 git status 3.删除命令 git rm “文件名”git commit -m “文件描述” 注意：提交到仓库的最好使用命令删除 远程仓库代码托管平台： 码云(gitee.com)：是开源中国社区团队推出的基于Git的快速的、免费的、稳定的在线代码托管平台，不限制私有库和公有库数量。有个缺点是使用page功能时自定义域名需要付费。 github(github.com)：是全球最大的开源社区，基于git的版本托管平台。私有库需要付费，访问速度慢。之前申请的号无故被封，还是得用~ 1.创建SSHkey，以github举例 ssh-keygen -t rsa -C “邮箱” 将此ssh添加到Github的个人设置中的SSH中 ssh -T git@github.com显示Hi，xxxxx就说明成功了 2.创建origin git remote add origin “远程仓库名” //添加远程仓库git remote -v //查看当前绑定仓库git remote remove “远程仓库名” //删除远程仓库 3.向远程仓库推送 git push -u origin mastergit pull origin master //同步远程仓库到本地 4.克隆仓库 git clone “远程仓库名”]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法(Hexo)]]></title>
    <url>%2F2018%2F11%2F02%2FMarkdown%E8%AF%AD%E6%B3%95-Hexo%2F</url>
    <content type="text"><![CDATA[转载：https://blog.csdn.net/zhuzhuyule/article/details/58347687?utm_source=blogxgwz2 Hexo下的Markdown语法Markdown时一种轻量级的标记语言，优点在于： 专注专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明描述分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， 文字 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 开头或， 使用`三个反引号 代码内容 三个反引号（Esc下边的键） 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt; ## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt; ### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt; #### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt; ##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt; ###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 内容强调加粗、斜体字体 **加粗** 显示 字体 *斜体* 显示 字体 ***加粗并斜体*** 显示 字体 __加粗__ 显示 字体 _斜体_ 显示 字体 ___加粗并斜体___ 显示 组合 *__加粗并斜体__* 显示 删除线~~删除一段文本~~ 高亮使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调 比如`突出背景色`来显示强调效果 引用显示标准使用 &gt; 每行开始都使用 &apos;&gt;&apos;； &gt; 引用**开始**； &gt; 引用**换行**； &gt; 引用**结束**。 &gt; 还在引用中！ 两个回车结束引用！ 省略使用 &gt; 仅第一行加应用； 引用开始； 引用换行； 引用结束； 两个回车结束引用,不在引用范围内了！ 表格表格语法： 列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 可以使用冒号来定义对齐方式： | 左对齐 | 右对齐 | 居中 | | :---- | ----:| :--: | 代码块*代码块语法遵循标准 markdown 代码，使用三个反引号开始，三个反引号结束 例如： 1234```JavaSystem.out.println(&quot;Hello World&quot;)``` 特别提示 如何在代码块中打出 三个反引号 实际上是使用 4个` 包含 3个` 就可以了，想表示更多，最外层+1就好了。 1234`````````````` 链接插入[博客]https://www.zwjblog.top 图片插入![我的头像]https://www.zwjblog.top/images/qqtouxiang.jpg 列表无序列表* *列表展示 * *列表展示 * *列表展示 + +列表展示 + +列表展示 + +列表展示 - -列表展示 - -列表展示 - -列表展示 效果如下： *列表展示 *列表展示 *列表展示 +列表展示 +列表展示 +列表展示 -列表展示 -列表展示 -列表展示 有序列表这种方式不用手动设置序号，自动生成列表序列 1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. 还是二级序列，没有三级序列 效果如下： 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 还是二级序列，没有三级序列 // //多于二级序列一个空格，仍然是二级序列 链接自动检测博客：https://www.zwjblog.top]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的基本理解]]></title>
    <url>%2F2018%2F11%2F02%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[主要参考https://www.cnblogs.com/lwbqqyumidi/p/3804883.html 线程(Thread类)、程序和进程关系：一个程序至少有一个进程，一个进程至少有一个线程。进程是程序在计算机上的一次执行活动，是资源分配的基本单位。线程是调度的基本单位，进程包含线程，线程共用进程的资源。进程是资源分配单位，线程是CPU调度单位。 一、线程的生命周期及五种基本状态这是一张比较经典的图片 Java线程具有五种基本状态新建状态（New）：当线程对象创建后，即进入了新建状态，如 Thread t = new MyThread();就绪状态（Runnable）：当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了start()此线程立即就会执行；运行状态（Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注意：就绪状态是进入到运行状态的唯一入口，也就是说，线程想要进入运行状态执行首先必须处于就绪状态中；阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；2.同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态；3.其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二、Java多项成的创建及启动Java中线程的创建常见有三种基本形式1.继承Thread类，重写该类的run()方法。 class MyThread extends Thread{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest{ public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30){ //创建一个新的线程myThread1此线程进入新建状态 Thread myThread1 = new MyThread(); //创建一个新的线程myThread2此线程进入新建状态 Thread myThread2 = new MyThread(); //调用start()方法使得线程进入就绪状态 myThread1.start(); //调用start()方法使得线程进入就绪状态 myThread2.start(); } } } } 输出的结果： main 0 ~ main 99 Thread-0 0 ~ Thread-0 99 Thread-0 0 ~ Thread-0 99 可以看出虽然当i == 30时，进入判断体，但是线程并没有马上执行，这取决于CPU的调度时机2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实体类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread独享才是真正的线程对象。 class MyRunnable implements Runnable{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest { public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } //创建一个Runnable实现类的对象 Runnable myRunnable = new MyRunnable(); //将myRunnable作为Thread target创建新的线程 Thread thread1 = new Thread(myRunnable); //调用start()方法使得线程进入就绪状态 thread1.start(); } } 与实现Runnable接口创建线程方式相似，不同的地方在于 Thread thread = new MyThread(myRunnable); public interface Runnable { public abstract void run(); } @Override public void run() { if (target != null) { target.run(); } } 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; { //.... } public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; { void run(); } 注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat]]></title>
    <url>%2F2018%2F11%2F02%2FSimpleDateFormat%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat的一些常用语法 转自http://www.cnblogs.com/qiangqiangqiang/p/7680752.html SimpleDateFormat函数语法注意大小写 G 年代标志符y 年M 月d 日h 时 在上午或下午 (1~12)H 时 在一天中 (0~23)m 分s 秒S 毫秒E 星期D 一年中的第几天F 一月中第几个星期几w 一年中第几个星期W 一月中第几个星期a 上午 / 下午 标记符k 时 在一天中 (1~24)K 时 在上午或下午 (0~11)z 时区 SimpleDateFormat aDate=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); SimpleDateFormat bDate=new SimpleDateFormat(&quot;yyyy-mmmmmm-dddddd&quot;); long now = System.currentTimeMillis(); 运行结果： 2018-11-02 14:40:482018-000040-000002 SimpleDateFormat myFmt=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); SimpleDateFormat myFmt1=new SimpleDateFormat(&quot;yy/MM/dd HH:mm&quot;); SimpleDateFormat myFmt2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//等价于now.toLocaleString() SimpleDateFormat myFmt3=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;); SimpleDateFormat myFmt4=new SimpleDateFormat( &quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;); 运行结果： 2018-11-02 14:41:552018-000041-0000022018年11月02日 14时41分55秒18/11/02 14:412018-11-02 14:41:552018年11月02日 14时41分55秒 星期五一年中的第 306 天 一年中第44个星期 一月中第1个星期 在一天中14时 CST时区 笔试题：求10天后的时间，并以”yyyy年MM月dd日”格式输出 import java.text.SimpleDateFormat; public class Test { public static void main(String[] args) { //格式化日期 SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //当前系统时间加上10天的时间，单位（毫秒） long tenday = System.currentTimeMillis() + 10 * 24 * 60 * 60 * 1000; //输出 System.out.println(date.format(tenday)); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目SpringBoot]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AESpringBoot%2F</url>
    <content type="text"><![CDATA[前端部分后补充 后端部分摘自老师的笔记 一、环境搭建和工具 所需环境：java,mysql,tomcat 使用工具：IDEA,Navicat 二、数据库的设计表设计 类目create table `product_category` ( `category_id` int not null auto_increment, `category_name` varchar(64) not null comment &apos;类目名字&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`category_id`) ); 商品create table `product_info` ( `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;单价&apos;, `product_stock` int not null comment &apos;库存&apos;, `product_description` varchar(64) comment &apos;描述&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `product_status` tinyint(3) DEFAULT &apos;0&apos; COMMENT &apos;商品状态,0正常1下架&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`product_id`) ); 订单create table `order_master` ( `order_id` varchar(32) not null, `buyer_name` varchar(32) not null comment &apos;买家名字&apos;, `buyer_phone` varchar(32) not null comment &apos;买家电话&apos;, `buyer_address` varchar(128) not null comment &apos;买家地址&apos;, `buyer_openid` varchar(64) not null comment &apos;买家微信openid&apos;, `order_amount` decimal(8,2) not null comment &apos;订单总金额&apos;, `order_status` tinyint(3) not null default &apos;0&apos; comment &apos;订单状态, 默认为新下单&apos;, `pay_status` tinyint(3) not null default &apos;0&apos; comment &apos;支付状态, 默认未支付&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`order_id`), key `idx_buyer_openid` (`buyer_openid`) ); 订单商品create table `order_detail` ( `detail_id` varchar(32) not null, `order_id` varchar(32) not null, `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;当前价格,单位分&apos;, `product_quantity` int not null comment &apos;数量&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`detail_id`), key `idx_order_id` (`order_id`) ); 卖家create table `seller_info` ( `id` varchar(32) not null, `username` varchar(32) not null, `password` varchar(32) not null, `openid` varchar(64) not null comment &apos;微信openid&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`id`) ) comment &apos;卖家信息表&apos;; 三、Api文档商品列表 GET /sell/buyer/product/list 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;name&quot;: &quot;热榜&quot;, &quot;type&quot;: 1, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;皮蛋粥&quot;, &quot;price&quot;: 1.2, &quot;description&quot;: &quot;好吃的皮蛋粥&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] }, { &quot;name&quot;: &quot;好吃的&quot;, &quot;type&quot;: 2, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123457&quot;, &quot;name&quot;: &quot;蛋糕&quot;, &quot;price&quot;: 10.9, &quot;description&quot;: &quot;美味爽口&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] } ] } 创建订单 POST /sell/buyer/order/create 参数 name: &quot;张三&quot; phone: &quot;13333333333&quot; address: &quot;西七道&quot; openid: &quot;ew3euwhd7sjw9diwkq&quot; //用户的微信openid items: [{ productId: &quot;1423113435324&quot;, productQuantity: 2 //购买数量 }] 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;147283992738221&quot; } } 订单列表 GET /sell/buyer/order/list 参数 openid: 18eu2jwk2kse3r42e2e page: 0 //从第0页开始 size: 10 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;orderId&quot;: &quot;161873371171128075&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }, { &quot;orderId&quot;: &quot;161873371171128076&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }] } 查询订单详情 GET /sell/buyer/order/detail 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;buyerName&quot;: &quot;李四&quot;, &quot;buyerPhone&quot;: &quot;15555555555&quot;, &quot;buyerAddress&quot;: &quot;西八道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 18, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490177352, &quot;updateTime&quot;: 1490177352, &quot;orderDetailList&quot;: [ { &quot;detailId&quot;: &quot;161899085974995851&quot;, &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;productId&quot;: &quot;157875196362360019&quot;, &quot;productName&quot;: &quot;招牌奶茶&quot;, &quot;productPrice&quot;: 9, &quot;productQuantity&quot;: 2, &quot;productIcon&quot;: &quot;http://xxx.com&quot;, &quot;productImage&quot;: &quot;http://xxx.com&quot; } ] } } 取消订单 POST /sell/buyer/order/cancel 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: null } 获取openid 重定向到 /sell/wechat/authorize 参数 returnUrl: http://xxx.com/abc //【必填】 返回 http://xxx.com/abc?openid=oZxSYw5ldcxv6H0EU67GgSXOUrVg 支付订单 重定向 /sell/pay/create 参数 orderId: 161899085773669363 returnUrl: http://xxx.com/abc/order/161899085773669363 返回 http://xxx.com/abc/order/161899085773669363 四、买家类目1.dao层需要的方法根据categoryType的集合来查询 2.service需要的方法根据id查询查询所有根据categoryType的集合来查询新增和更新 五、商品1.dao层需要的方法根据商品状态来查询 2.service层需要的方法根据id查询查询所有上架商品查询所有商品（给管理端使用，需要包含分页）增加和修改方法 3.买家端API的开发提供一个查询所有商品和类别的api接口（需要重新包装数据）]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>nginx</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F10%2F29%2Fspringboot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringBoot项目的构建有三种方式：一、手动构建利用maven构建一个普通的项目，我们手动去加入依赖。 1.在pom中引入父pom,代码如下&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.17.RELEASE&lt;/version&gt; &lt;/parent&gt; 2.引入SpringBoot依赖，代码如下&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3.加入编译插件&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4.写一个启动类@Controller //可以帮助SpringBoot应用将所有符合条件的@Configuration配置 都加载到当前SpringBoot创建并使用的IoC容器。 @EnableAutoConfiguration public class BootStarter { //servlet映射地址 @RequestMapping(&quot;/hello&quot;) //返回json格式的数据 @ResponseBody public String hello(){ return &quot;hello world&quot;; } public static void main(String[] args) { // SpringApplication.run(BootStarter.class,args); } } 5.运行main方法，在地址栏访问localhost:8080/hello . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.17.RELEASE) 启动成功！ 二、Spring官网Spring官网为我们提供了生成项目的方式访问https://start.spring.io/根据提示填写，下载解压使用IDEA将项目打开 三、利用IDEA工具新建项目直接选择Spring Initializr就可以生成一个Spring Boot项目（常用）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于node.js,hexo,github搭建博客]]></title>
    <url>%2F2018%2F10%2F29%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[基于 node.js+hexo+github 搭建一个属于自己的博客！ 前言&emsp;&emsp;从买阿里云服务器开始说起，开始研究服务器到底能做什么，最开始了解到云服务器可以是一台24小时运行的电脑，并且拥有自己的IP，就想着先把做的仿饿了么外卖项目放到服务器上运行，经过无数的踩坑，从linux系统都不会进到后面的关防火墙，配置安全组。再到搭建Node.js环境，git环境，连接github，终于让项目跑起来。再开始想怎样实现员工管理系统也能在服务器上运行，又开始配置JDK，Mysql，Tomcat环境，最后几经周折也实现了（虽然还有）一些BUG。 &emsp;&emsp;通过阿里云，又了解了域名相关，就想着自己是不是可以拥有一个属于自己的域名，比如说自定义的博客，也可以在服务器上跑（不能让它闲着–！），就开始在网上搜寻相关的知识。开始真的是一头雾水，别人是一步一个脚印，我感觉我是一步一个坑，最后摸索出用node.js+hexo+github 就可以实现我想要的结果，不容易不容易。 正题配置环境我们需要配置所需要的工具node.js+hexo+github这里就暂时不做过多解释，只给出检测的方法。在一个空文件夹下，右键Git Bash here node -version npm -version git -version 都能显示版本说明我们可以开始搭建了。 hexo初始化我们需要一个官方默认的hexo主题，在Git界面执行以下命令 hexo init 这是遇到的一个大坑，几KB每秒的下载速度，最后还卡住了，果断扔到服务器上下载。我上传到百度网盘，可以下载，下载后不需要执行上面的代码。 链接：https://pan.baidu.com/s/1QZSevQU6zkvJ55DnFUWQMQ提取码：m67r 接下来我们需要配置hexo和node依赖的包 npm install 这时我们可以查看hexo是否初始化 hexo -version 显示版本就说明hexo可以使用。 git部分git这部分，我们需要将此文件夹下的文件利用下面的代码先推到git中 git init git add -A git commit -m &quot;提交&quot; git remote add origin &quot;你的github仓库&quot; 这里需要注意的是：不要往仓库上推，仓库存的不是这部分文件，而是一些静态资源文件，比如html、css和js文件。 hexo主题生成清理静态资源文件 hexo clean 生成静态资源文件 hexo g 部署项目，通过localhost:4000访问 hexo s 页面出现Hexo，此时就说明成功了&emsp;&emsp;接下来的就比较简单了，打开hexo下的_config.yml文件，这个文件包含了hexo的站点配置，在最下方需要添加代码 deploy: type: git repo: &quot;这里填写你的github仓库&quot; branch: master &emsp;&emsp;这个时候千万不要用git pull或者git push等命令！应该使用 hexo clean hexo g hexo d hexo d这个命令就可以把你的项目提交到你的github仓库中。 github网址生成&emsp;&emsp;github对我们很友好（吐槽下真的很慢），为我们提供了一个功能，生成了一个网址可以展示仓库中的项目，但这个功能需要手动开启，打开我们的github，找到对应的仓库，找到Setting选项下的GitHub Pages，选择Source中你项目的分支，一般是主分支。实在不行开个翻译，很好找，点击保存后，这样就会显示一个网址，这样就可以访问了。注意：项目名需要xxx.github.io的格式，还需要在_config.yml中找到以下代码。 url: &quot;你生成的网址&quot; root: /项目名 结束语&emsp;&emsp;仔细回想一下，其实挺简单的，主要是什么都不知道，还有没想到的以后再进行补充，欢迎留言评论。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
