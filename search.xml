<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven远程仓库]]></title>
    <url>%2F2018%2F11%2F05%2FMaven%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Maven配置中央仓库maven作为一个项目管理工具确实为我们提供了很大的方便，但是在国内这个网络下对我们就不是很友好了，阿里云和华为云都为我们提供了中央仓库，个人推荐华为云，因为在学习SpringBoot时，出现了jar包缺少依赖的问题，而华为云没有。 本地仓库在这里先提一下修改本地仓库的储存路径，默认情况下maven会在用户目录下创建.m2/repository/的仓库目录，但一般情况下，我们不希望在C盘有过多的文件，我们需要在找到 \apache-maven\conf\settings.xml 打开，找到settings标签 &lt;settings&gt; //将默认仓库注释掉，添加自定义仓库路径 &lt;localRepository&gt;D:\Program Files\JAVA\mavenRepository&lt;/localRepository&gt; &lt;/settings&gt; 这样maven下载jar包的时候就会下载到自定义路径中 阿里云中央仓库修改远程仓库为阿里云中央仓库 还是在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 这样就配置成功了 华为云中央仓库修改远程仓库为华为云中央仓库 操作差不多，需要多加一步，先在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt; &lt;/mirror&gt; 还需要在servers标签中添加一个server &lt;servers&gt; &lt;server&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;username&gt;anonymous&lt;/username&gt; &lt;password&gt;devcloud&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 开始体验飞一般的下载速度吧！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的基本使用]]></title>
    <url>%2F2018%2F11%2F03%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git简介Git是目前世界上最先进的分布式版本控制系统。Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。 Git下载https://git-scm.com/downloads一路next就可以在桌面右键出现Git Bash here和Git GUI here就说明成功了 Git基本使用配置用户名，邮箱 git config –global user.email “你的邮箱”git config –global user.name “你的用户名” 这个是用来配置本地仓库的，可以随意填写 创建一个本地版本仓库接下来我们创建第一个仓库1.创建一个空白文件夹，目录不包含中文，右键Git Bash here，输入 git init 我们可以看到当前目录出现了一个.git目录（这是个默认隐藏的文件夹）2.创建一个hellogit.txt文件3.添加文件到本地仓库 git add hellogit.txtgit commit -m “文件描述” 这样我们就把这个文件添加到了本地仓库4.把文件中加一些文字，执行以下命令 git status 查看仓库当前状态，提示有文件被修改了，需要再次执行git add和git commit 版本回退1.打印日志 git log //查看提交历史git reflog //查看命令历史git reset –hard “” //填写你想回退的版本的id 2.查看当前状态 git status 3.删除命令 git rm “文件名”git commit -m “文件描述” 注意：提交到仓库的最好使用命令删除 远程仓库代码托管平台： 码云(gitee.com)：是开源中国社区团队推出的基于Git的快速的、免费的、稳定的在线代码托管平台，不限制私有库和公有库数量。有个缺点是使用page功能时自定义域名需要付费。 github(github.com)：是全球最大的开源社区，基于git的版本托管平台。私有库需要付费，访问速度慢。之前申请的号无故被封，还是得用~ 1.创建SSHkey，以github举例 ssh-keygen -t rsa -C “邮箱” 将此ssh添加到Github的个人设置中的SSH中 ssh -T git@github.com显示Hi，xxxxx就说明成功了 2.创建origin git remote add origin “远程仓库名” //添加远程仓库git remote -v //查看当前绑定仓库git remote remove “远程仓库名” //删除远程仓库 3.向远程仓库推送 git push -u origin mastergit pull origin master //同步远程仓库到本地 4.克隆仓库 git clone “远程仓库名”]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法(Hexo)]]></title>
    <url>%2F2018%2F11%2F02%2FMarkdown%E8%AF%AD%E6%B3%95-Hexo%2F</url>
    <content type="text"><![CDATA[转载：https://blog.csdn.net/zhuzhuyule/article/details/58347687?utm_source=blogxgwz2 Hexo下的Markdown语法Markdown时一种轻量级的标记语言，优点在于： 专注专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明描述分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， 文字 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 开头或， 使用`三个反引号 代码内容 三个反引号（Esc下边的键） 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt; ## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt; ### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt; #### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt; ##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt; ###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 内容强调加粗、斜体字体 **加粗** 显示 字体 *斜体* 显示 字体 ***加粗并斜体*** 显示 字体 __加粗__ 显示 字体 _斜体_ 显示 字体 ___加粗并斜体___ 显示 组合 *__加粗并斜体__* 显示 删除线~~删除一段文本~~ 高亮使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调 比如`突出背景色`来显示强调效果 引用显示标准使用 &gt; 每行开始都使用 &apos;&gt;&apos;； &gt; 引用**开始**； &gt; 引用**换行**； &gt; 引用**结束**。 &gt; 还在引用中！ 两个回车结束引用！ 省略使用 &gt; 仅第一行加应用； 引用开始； 引用换行； 引用结束； 两个回车结束引用,不在引用范围内了！ 表格表格语法： 列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 可以使用冒号来定义对齐方式： | 左对齐 | 右对齐 | 居中 | | :---- | ----:| :--: | 代码块*代码块语法遵循标准 markdown 代码，使用三个反引号开始，三个反引号结束 例如： 1234```JavaSystem.out.println(&quot;Hello World&quot;)``` 特别提示 如何在代码块中打出 三个反引号 实际上是使用 4个` 包含 3个` 就可以了，想表示更多，最外层+1就好了。 1234`````````````` 链接插入[博客]https://www.zwjblog.top 图片插入![我的头像]https://www.zwjblog.top/images/qqtouxiang.jpg 列表无序列表* *列表展示 * *列表展示 * *列表展示 + +列表展示 + +列表展示 + +列表展示 - -列表展示 - -列表展示 - -列表展示 效果如下： *列表展示 *列表展示 *列表展示 +列表展示 +列表展示 +列表展示 -列表展示 -列表展示 -列表展示 有序列表这种方式不用手动设置序号，自动生成列表序列 1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. 还是二级序列，没有三级序列 效果如下： 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 还是二级序列，没有三级序列 // //多于二级序列一个空格，仍然是二级序列 链接自动检测博客：https://www.zwjblog.top]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的基本理解]]></title>
    <url>%2F2018%2F11%2F02%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[主要参考https://www.cnblogs.com/lwbqqyumidi/p/3804883.html 线程(Thread类)、程序和进程关系：一个程序至少有一个进程，一个进程至少有一个线程。进程是程序在计算机上的一次执行活动，是资源分配的基本单位。线程是调度的基本单位，进程包含线程，线程共用进程的资源。进程是资源分配单位，线程是CPU调度单位。 一、线程的生命周期及五种基本状态这是一张比较经典的图片 Java线程具有五种基本状态新建状态（New）：当线程对象创建后，即进入了新建状态，如 Thread t = new MyThread();就绪状态（Runnable）：当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了start()此线程立即就会执行；运行状态（Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注意：就绪状态是进入到运行状态的唯一入口，也就是说，线程想要进入运行状态执行首先必须处于就绪状态中；阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；2.同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态；3.其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二、Java多项成的创建及启动Java中线程的创建常见有三种基本形式1.继承Thread类，重写该类的run()方法。 class MyThread extends Thread{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest{ public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30){ //创建一个新的线程myThread1此线程进入新建状态 Thread myThread1 = new MyThread(); //创建一个新的线程myThread2此线程进入新建状态 Thread myThread2 = new MyThread(); //调用start()方法使得线程进入就绪状态 myThread1.start(); //调用start()方法使得线程进入就绪状态 myThread2.start(); } } } } 输出的结果： main 0 ~ main 99 Thread-0 0 ~ Thread-0 99 Thread-0 0 ~ Thread-0 99 可以看出虽然当i == 30时，进入判断体，但是线程并没有马上执行，这取决于CPU的调度时机2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实体类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread独享才是真正的线程对象。 class MyRunnable implements Runnable{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest { public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } //创建一个Runnable实现类的对象 Runnable myRunnable = new MyRunnable(); //将myRunnable作为Thread target创建新的线程 Thread thread1 = new Thread(myRunnable); //调用start()方法使得线程进入就绪状态 thread1.start(); } } 与实现Runnable接口创建线程方式相似，不同的地方在于 Thread thread = new MyThread(myRunnable); public interface Runnable { public abstract void run(); } @Override public void run() { if (target != null) { target.run(); } } 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; { //.... } public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; { void run(); } 注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat]]></title>
    <url>%2F2018%2F11%2F02%2FSimpleDateFormat%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat的一些常用语法 转自http://www.cnblogs.com/qiangqiangqiang/p/7680752.html SimpleDateFormat函数语法注意大小写 G 年代标志符y 年M 月d 日h 时 在上午或下午 (1~12)H 时 在一天中 (0~23)m 分s 秒S 毫秒E 星期D 一年中的第几天F 一月中第几个星期几w 一年中第几个星期W 一月中第几个星期a 上午 / 下午 标记符k 时 在一天中 (1~24)K 时 在上午或下午 (0~11)z 时区 SimpleDateFormat aDate=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); SimpleDateFormat bDate=new SimpleDateFormat(&quot;yyyy-mmmmmm-dddddd&quot;); long now = System.currentTimeMillis(); 运行结果： 2018-11-02 14:40:482018-000040-000002 SimpleDateFormat myFmt=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); SimpleDateFormat myFmt1=new SimpleDateFormat(&quot;yy/MM/dd HH:mm&quot;); SimpleDateFormat myFmt2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//等价于now.toLocaleString() SimpleDateFormat myFmt3=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;); SimpleDateFormat myFmt4=new SimpleDateFormat( &quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;); 运行结果： 2018-11-02 14:41:552018-000041-0000022018年11月02日 14时41分55秒18/11/02 14:412018-11-02 14:41:552018年11月02日 14时41分55秒 星期五一年中的第 306 天 一年中第44个星期 一月中第1个星期 在一天中14时 CST时区 笔试题：求10天后的时间，并以”yyyy年MM月dd日”格式输出 import java.text.SimpleDateFormat; public class Test { public static void main(String[] args) { //格式化日期 SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //当前系统时间加上10天的时间，单位（毫秒） long tenday = System.currentTimeMillis() + 10 * 24 * 60 * 60 * 1000; //输出 System.out.println(date.format(tenday)); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目SpringBoot]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AESpringBoot%2F</url>
    <content type="text"><![CDATA[前端部分后补充 后端部分摘自老师的笔记 一、环境搭建和工具 所需环境：java,mysql,tomcat 使用工具：IDEA,Navicat 二、数据库的设计表设计 类目create table `product_category` ( `category_id` int not null auto_increment, `category_name` varchar(64) not null comment &apos;类目名字&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`category_id`) ); 商品create table `product_info` ( `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;单价&apos;, `product_stock` int not null comment &apos;库存&apos;, `product_description` varchar(64) comment &apos;描述&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `product_status` tinyint(3) DEFAULT &apos;0&apos; COMMENT &apos;商品状态,0正常1下架&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`product_id`) ); 订单create table `order_master` ( `order_id` varchar(32) not null, `buyer_name` varchar(32) not null comment &apos;买家名字&apos;, `buyer_phone` varchar(32) not null comment &apos;买家电话&apos;, `buyer_address` varchar(128) not null comment &apos;买家地址&apos;, `buyer_openid` varchar(64) not null comment &apos;买家微信openid&apos;, `order_amount` decimal(8,2) not null comment &apos;订单总金额&apos;, `order_status` tinyint(3) not null default &apos;0&apos; comment &apos;订单状态, 默认为新下单&apos;, `pay_status` tinyint(3) not null default &apos;0&apos; comment &apos;支付状态, 默认未支付&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`order_id`), key `idx_buyer_openid` (`buyer_openid`) ); 订单商品create table `order_detail` ( `detail_id` varchar(32) not null, `order_id` varchar(32) not null, `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;当前价格,单位分&apos;, `product_quantity` int not null comment &apos;数量&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`detail_id`), key `idx_order_id` (`order_id`) ); 卖家create table `seller_info` ( `id` varchar(32) not null, `username` varchar(32) not null, `password` varchar(32) not null, `openid` varchar(64) not null comment &apos;微信openid&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`id`) ) comment &apos;卖家信息表&apos;; 三、Api文档商品列表 GET /sell/buyer/product/list 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;name&quot;: &quot;热榜&quot;, &quot;type&quot;: 1, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;皮蛋粥&quot;, &quot;price&quot;: 1.2, &quot;description&quot;: &quot;好吃的皮蛋粥&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] }, { &quot;name&quot;: &quot;好吃的&quot;, &quot;type&quot;: 2, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123457&quot;, &quot;name&quot;: &quot;蛋糕&quot;, &quot;price&quot;: 10.9, &quot;description&quot;: &quot;美味爽口&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] } ] } 创建订单 POST /sell/buyer/order/create 参数 name: &quot;张三&quot; phone: &quot;13333333333&quot; address: &quot;西七道&quot; openid: &quot;ew3euwhd7sjw9diwkq&quot; //用户的微信openid items: [{ productId: &quot;1423113435324&quot;, productQuantity: 2 //购买数量 }] 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;147283992738221&quot; } } 订单列表 GET /sell/buyer/order/list 参数 openid: 18eu2jwk2kse3r42e2e page: 0 //从第0页开始 size: 10 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;orderId&quot;: &quot;161873371171128075&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }, { &quot;orderId&quot;: &quot;161873371171128076&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }] } 查询订单详情 GET /sell/buyer/order/detail 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;buyerName&quot;: &quot;李四&quot;, &quot;buyerPhone&quot;: &quot;15555555555&quot;, &quot;buyerAddress&quot;: &quot;西八道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 18, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490177352, &quot;updateTime&quot;: 1490177352, &quot;orderDetailList&quot;: [ { &quot;detailId&quot;: &quot;161899085974995851&quot;, &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;productId&quot;: &quot;157875196362360019&quot;, &quot;productName&quot;: &quot;招牌奶茶&quot;, &quot;productPrice&quot;: 9, &quot;productQuantity&quot;: 2, &quot;productIcon&quot;: &quot;http://xxx.com&quot;, &quot;productImage&quot;: &quot;http://xxx.com&quot; } ] } } 取消订单 POST /sell/buyer/order/cancel 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: null } 获取openid 重定向到 /sell/wechat/authorize 参数 returnUrl: http://xxx.com/abc //【必填】 返回 http://xxx.com/abc?openid=oZxSYw5ldcxv6H0EU67GgSXOUrVg 支付订单 重定向 /sell/pay/create 参数 orderId: 161899085773669363 returnUrl: http://xxx.com/abc/order/161899085773669363 返回 http://xxx.com/abc/order/161899085773669363 四、买家类目1.dao层需要的方法根据categoryType的集合来查询 2.service需要的方法根据id查询查询所有根据categoryType的集合来查询新增和更新 五、商品1.dao层需要的方法根据商品状态来查询 2.service层需要的方法根据id查询查询所有上架商品查询所有商品（给管理端使用，需要包含分页）增加和修改方法 3.买家端API的开发提供一个查询所有商品和类别的api接口（需要重新包装数据）]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>springboot,nginx,node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F10%2F29%2Fspringboot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringBoot项目的构建有三种方式：一、手动构建利用maven构建一个普通的项目，我们手动去加入依赖。 1.在pom中引入父pom,代码如下&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.17.RELEASE&lt;/version&gt; &lt;/parent&gt; 2.引入SpringBoot依赖，代码如下&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3.加入编译插件&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4.写一个启动类@Controller //可以帮助SpringBoot应用将所有符合条件的@Configuration配置 都加载到当前SpringBoot创建并使用的IoC容器。 @EnableAutoConfiguration public class BootStarter { //servlet映射地址 @RequestMapping(&quot;/hello&quot;) //返回json格式的数据 @ResponseBody public String hello(){ return &quot;hello world&quot;; } public static void main(String[] args) { // SpringApplication.run(BootStarter.class,args); } } 5.运行main方法，在地址栏访问localhost:8080/hello . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.17.RELEASE) 启动成功！ 二、Spring官网Spring官网为我们提供了生成项目的方式访问https://start.spring.io/根据提示填写，下载解压使用IDEA将项目打开 三、利用IDEA工具新建项目直接选择Spring Initializr就可以生成一个Spring Boot项目（常用）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于node.jshexo,github搭建博客]]></title>
    <url>%2F2018%2F10%2F29%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[基于 node.js+hexo+github 搭建一个属于自己的博客！ 前言&emsp;&emsp;从买阿里云服务器开始说起，开始研究服务器到底能做什么，最开始了解到云服务器可以是一台24小时运行的电脑，并且拥有自己的IP，就想着先把做的仿饿了么外卖项目放到服务器上运行，经过无数的踩坑，从linux系统都不会进到后面的关防火墙，配置安全组。再到搭建Node.js环境，git环境，连接github，终于让项目跑起来。再开始想怎样实现员工管理系统也能在服务器上运行，又开始配置JDK，Mysql，Tomcat环境，最后几经周折也实现了（虽然还有）一些BUG。 &emsp;&emsp;通过阿里云，又了解了域名相关，就想着自己是不是可以拥有一个属于自己的域名，比如说自定义的博客，也可以在服务器上跑（不能让它闲着–！），就开始在网上搜寻相关的知识。开始真的是一头雾水，别人是一步一个脚印，我感觉我是一步一个坑，最后摸索出用node.js+hexo+github 就可以实现我想要的结果，不容易不容易。 正题配置环境我们需要配置所需要的工具node.js+hexo+github这里就暂时不做过多解释，只给出检测的方法。在一个空文件夹下，右键Git Bash here node -version npm -version git -version 都能显示版本说明我们可以开始搭建了。 hexo初始化我们需要一个官方默认的hexo主题，在Git界面执行以下命令 hexo init 这是遇到的一个大坑，几KB每秒的下载速度，最后还卡住了，果断扔到服务器上下载。我上传到百度网盘，可以下载，下载后不需要执行上面的代码。 链接：https://pan.baidu.com/s/1QZSevQU6zkvJ55DnFUWQMQ提取码：m67r 接下来我们需要配置hexo和node依赖的包 npm install 这时我们可以查看hexo是否初始化 hexo -version 显示版本就说明hexo可以使用。 git部分git这部分，我们需要将此文件夹下的文件利用下面的代码先推到git中 git init git add -A git commit -m &quot;提交&quot; git remote add origin &quot;你的github仓库&quot; 这里需要注意的是：不要往仓库上推，仓库存的不是这部分文件，而是一些静态资源文件，比如html、css和js文件。 hexo主题生成清理静态资源文件 hexo clean 生成静态资源文件 hexo g 部署项目，通过localhost:4000访问 hexo s 页面出现Hexo，此时就说明成功了&emsp;&emsp;接下来的就比较简单了，打开hexo下的_config.yml文件，这个文件包含了hexo的站点配置，在最下方需要添加代码 deploy: type: git repo: &quot;这里填写你的github仓库&quot; branch: master &emsp;&emsp;这个时候千万不要用git pull或者git push等命令！应该使用 hexo clean hexo g hexo d hexo d这个命令就可以把你的项目提交到你的github仓库中。 github网址生成&emsp;&emsp;github对我们很友好（吐槽下真的很慢），为我们提供了一个功能，生成了一个网址可以展示仓库中的项目，但这个功能需要手动开启，打开我们的github，找到对应的仓库，找到Setting选项下的GitHub Pages，选择Source中你项目的分支，一般是主分支。实在不行开个翻译，很好找，点击保存后，这样就会显示一个网址，这样就可以访问了。注意：项目名需要xxx.github.io的格式，还需要在_config.yml中找到以下代码。 url: &quot;你生成的网址&quot; root: /项目名 结束语&emsp;&emsp;仔细回想一下，其实挺简单的，主要是什么都不知道，还有没想到的以后再进行补充，欢迎留言评论。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
