<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[美团酒店爬虫]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%BE%8E%E5%9B%A2%E9%85%92%E5%BA%97%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[先来看看百度概念：网络爬虫： 又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的成为网页追逐者，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 自己的理解暂时是，用程序帮我们去发送请求，获取数据，也可以获取html中的信息。 一个朋友需要合肥美团酒店的信息。 最开始的想法是利用fiddler去截取手机app中请求，找到获取数据的请求以及所需要的参数，但是失败了，fiddler的证书之前我给删了，怎么也安不上QAQ，难受。经过一番百度，发现美团这个网址好像就是手机端的，然后大概想法就是找到获取数据的请求地址以及所需要的参数，然后利用okhttp发送请求，获取数据流，利用jackson反序列化为对象，再用poi工具导出excel文件。 有了想法就开始搞 美团酒店合肥地区找到页面，F12开发者工具Network中，发现 HotelSearch这个请求应该就是获取数据了。丢到postman看看，返回的是json格式的，limit有限制应该是30多，offset从第几行，uuid暂时没什么好办法，访问一次写死。能拿到数据就能动手写了，随便搞个springboot项目跑起来。spring-boot-starter-web和okhttp依赖。开启spring定时任务 启动类加@EnableScheduling创建一个工具类OkhttpUtils,交给spring容器管理@Component // 每次取30行 int limit = 30; // 从第offset行取 int offset = 0; /** * 1.cron是设置定时执行的表达式，如 0 0/5 * * * ?每隔五分钟执行一次 秒 分 时 天 月 2.zone表示执行时间的时区 3.fixedDelay 和fixedDelayString 表示一个固定延迟时间执行，上个任务完成后，延迟多长时间执行 4.fixedRate 和fixedRateString表示一个固定频率执行，上个任务开始后，多长时间后开始执行 5.initialDelay 和initialDelayString表示一个初始延迟时间，第一次被调用前延迟的时间 */ //@Scheduled(cron=&quot;0/3 * * * * ?&quot;) //@Scheduled(fixedDelay =200 * 1000) @Scheduled(initialDelay=1000, fixedRate=20 * 1000) public static void getRequest(){ // excel中的列名 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;historySaleCount&quot;,&quot;历史消费&quot;); map.put(&quot;frontImg&quot;,&quot;预览图&quot;); map.put(&quot;name&quot;,&quot;酒店名称&quot;); map.put(&quot;addr&quot;,&quot;地址&quot;); map.put(&quot;areaName&quot;,&quot;区域名称&quot;); map.put(&quot;lat&quot;,&quot;经度&quot;); map.put(&quot;lng&quot;,&quot;纬度&quot;); map.put(&quot;lowestPrice&quot;,&quot;最低价格&quot;); map.put(&quot;scoreIntro&quot;,&quot;评分&quot;); map.put(&quot;hotelStar&quot;,&quot;型&quot;); map.put(&quot;commentsCountDesc&quot;,&quot;评论总数&quot;); // jackson ObjectMapper mapper = new ObjectMapper(); // 请求url limit offset String url = &quot;https://ihotel.meituan.com/hbsearch/HotelSearch?utm_medium=touch&amp;version_name=999.9&amp;platformid=1&amp;cateId=20&amp;newcate=1&amp;limit=&quot; + limit +&quot;&amp;offset=&quot; + offset+ &quot;&amp;cityId=56&amp;ci=56&amp;startendday=20190603~20190603&amp;startDay=20190603&amp;endDay=20190603&amp;mypos=40.043888%2C116.340587&amp;attr_28=129&amp;sort=defaults&amp;uuid=BDD0ADA22FEB012F5848CEFD4A9478DFE998293D6D786607A8911CEE208CC1D6&quot;; System.out.println(&quot;第&quot;+ offset + &quot;行开始爬取&quot;); offset = offset + 30; // 忽略掉对象中没有的属性 mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // okhttp OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.Builder() .url(url) .build(); final Call call = okHttpClient.newCall(request); // 同步请求 new Thread(new Runnable() { @Override public void run() { try { // 响应 Response response = call.execute(); // 初始对象 取出json数据 InitialJson initData = mapper.readValue(response.body().string(), InitialJson.class); // 转化为酒店信息对象 List&lt;HotelInfo&gt; hotelInfos = initData.getData().getSearchresult(); // 工作表名称 String sheetName = &quot;美团酒店信息&quot;; // 开始时间 long start = System.currentTimeMillis(); // 导出excel ExcelUtils.excelExport(hotelInfos, map, sheetName); // 结束时间 long end = System.currentTimeMillis(); // 耗时 System.out.println(&quot;耗时：&quot;+(end-start)+&quot;ms&quot;); }catch (Exception e) { e.printStackTrace(); } } }).start(); } Excel工具类,用于将数据导出excel，需要依赖poi-ooxml // 忘了从哪拿的了-- public final class ExcelUtils { private ExcelUtils(){ } /** * 工作簿 */ private static HSSFWorkbook workbook; /** * sheet */ private static HSSFSheet sheet; /*** * 标题行开始位置 */ private static final int TITLE_START_POSITION = 0; /*** * 时间行开始位置 */ private static final int DATEHEAD_START_POSITION = 1; /*** * 表头行开始位置 */ private static final int HEAD_START_POSITION = 2; /*** * 文本行开始位置 */ private static final int CONTENT_START_POSITION = 3; @Autowired private ThreadPoolTaskExecutor executor; /** * * @param dataList 对象集合 * @param titleMap 表头信息 * @param sheetName sheet名称和表头值 */ public static void excelExport(List&lt;?&gt; dataList, Map&lt;String, String&gt; titleMap, String sheetName) { // 初始化workbook initHSSFWorkbook(sheetName); // 标题行 createTitleRow(titleMap, sheetName); // 时间行 createDateHeadRow(titleMap); // 表头行 createHeadRow(titleMap); // 文本行 createContentRow(dataList, titleMap); // 自动伸缩列 （耗内存） //autoSizeColumn(titleMap.size); // 写入处理结果 try { // 生成UUID文件名称 UUID uuid = UUID.randomUUID(); String filedisplay = uuid + &quot;.xls&quot;; OutputStream out = new FileOutputStream(&quot;D:\\excel\\ &quot; + filedisplay); workbook.write(out); out.close(); }catch (Exception e) { e.printStackTrace(); } } /** * 初始化workbook * @param sheetName */ private static void initHSSFWorkbook(String sheetName) { workbook = new HSSFWorkbook(); sheet = workbook.createSheet(sheetName); } /** * 生成标题（第零行创建） * @param titleMap 对象属性名称 -&gt; 表头显示名称 * @param sheetName sheet名称 */ private static void createTitleRow(Map&lt;String, String&gt; titleMap,String sheetName) { CellRangeAddress titleRange = new CellRangeAddress(0, 0, 0, titleMap.size() - 1); sheet.addMergedRegion(titleRange); HSSFRow titleRow = sheet.createRow(TITLE_START_POSITION); HSSFCell titleCell = titleRow.createCell(0); titleCell.setCellValue(sheetName); } /** * 创建时间行（第一行创建） * @param titleMap 对象属性名称 -&gt; 表头显示名称 */ private static void createDateHeadRow(Map&lt;String, String&gt; titleMap) { CellRangeAddress dateRange = new CellRangeAddress(1, 1, 0, titleMap.size() - 1 ); sheet.addMergedRegion(dateRange); HSSFRow dateRow = sheet.createRow(DATEHEAD_START_POSITION); HSSFCell dateCell = dateRow.createCell(0); dateCell.setCellValue(new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;).format(new Date())); } /** * 创建表头行（第二行创建） * @param titleMap 对象属性名称 -&gt; 表头显示名称 */ private static void createHeadRow(Map&lt;String, String&gt; titleMap) { //第一行创建 HSSFRow headRow = sheet.createRow(HEAD_START_POSITION); int i = 0; for (String entry : titleMap.keySet()) { HSSFCell headCell = headRow.createCell(i); headCell.setCellValue(titleMap.get(entry)); i++; } } /** * 对象属性集合 * @param dataList * @param titleMap 表头信息 */ private static void createContentRow(List&lt;?&gt; dataList, Map&lt;String, String&gt; titleMap) { int init = 0 try{ for (Object obj: dataList) { // 从第3行开始写入数据 HSSFRow textRow = sheet.createRow(CONTENT_START_POSITION + init); int j = 0; for (String entry : titleMap.keySet()) { // 利用反射获取属性方法 String method = &quot;get&quot; + entry.substring(0, 1).toUpperCase( ) + entry.substring(1); Method m = obj.getClass().getMethod(method, null); String value = m.invoke(obj, null).toString(); HSSFCell textcell = textRow.createCell(j); textcell.setCellValue(value); j++; } init++; } }catch (Exception e) { e.printStackTrace(); } } /** * 自动伸缩列 耗内存 * @param size 列数 */ private static void autoSizeColumn(Integer size) { for (int j = 0;j &lt; size; j++) { sheet.autoSizeColumn(j); } } } ok，跑起来就会在硬盘里生成多个xls文件，顺便学了下合并xls文件：wps -&gt; 数据 -&gt; 合并表格 -&gt; 多个工作表合并为一个工作表。把80多个xls合并成一个了，ok交差。 这部分数据主要是酒店的简介，名称，评分，地址，最低价格等。很明显满足不了需求呀~于是新的需求来了，要酒店的详细信息，比如联系方式，评价，入住时间等，这些肯定是得点进去才能看到的，那就点一下呗。美团酒店详细信息 这个请求地址有点长。。。不过不怕，我们发现 poi后边跟的是 /数字，一般来说就是对应的@PathVariable id占位符了，我找到之前爬出来的数据，发现poiid就是对应的id，有一点担心的是token，一般来说是做防止重复请求的，但测了一下发现，应该是时效性的token，对于我来说，影响不大，接下来的思路就是取出之前的poiid -&gt; 替换掉请求 -&gt; 获取数据 -&gt; 导出excel 一步一步来吧，首先我感觉从excel读poiid挺麻烦的，就想着能不能输出到txt里，感觉好取一些，生命在于折腾。 // 把导出excel替换掉 // 手动创了一个文件 String path = &quot;D:\\excel\\output.txt&quot;; // 后面的true很重要，不然每次会覆盖 FileWriter writer = new FileWriter(path, true); // 输出流 BufferedWriter out = new BufferedWriter(writer); out.flush(); out.close(); 这样我们就得到了全部的poiid，然后我们读取文件，将poiid放入一个集合 // 设为全局变量，获取酒店详细信息用 List&lt;String&gt; poiidList = new ArrayList&lt;&gt;(); // 就让它跑一次就够了 @Scheduled(fixedDelay =2000 * 1000) public void getPoiidList(){ try{ // 构造一个BufferedReader类来读取文件 BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\excel\\output.txt&quot;)); String s = null; // 使用readLine方法，一次读一行 while((s = br.readLine())!=null){ // 放入集合 poiidList.add(s); } br.close(); }catch(Exception e){ e.printStackTrace(); } } // 集合对应的下标即文件中对应的行数 int index = 0; // 1s执行一次，太快可能会导致封IP @Scheduled(initialDelay=1000, fixedRate=1000) public void getHotelInfo(){ // 构建属性名称 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;poiid&quot;,&quot;酒店id&quot;); map.put(&quot;addr&quot;,&quot;地址&quot;); map.put(&quot;lat&quot;,&quot;经度&quot;); map.put(&quot;lng&quot;,&quot;纬度&quot;); map.put(&quot;frontImg&quot;,&quot;预览图&quot;); map.put(&quot;name&quot;,&quot;酒店名称&quot;); map.put(&quot;introduction&quot;,&quot;描述&quot;); map.put(&quot;showType&quot;,&quot;酒店类型&quot;); map.put(&quot;areaName&quot;,&quot;区域名称&quot;); map.put(&quot;hotelStar&quot;,&quot;等级&quot;); map.put(&quot;phone&quot;,&quot;电话&quot;); map.put(&quot;useRuleIdentity&quot;,&quot;规定&quot;); map.put(&quot;useRuleTime&quot;,&quot;入住时间&quot;); map.put(&quot;avgScore&quot;,&quot;评分&quot;); map.put(&quot;scoreIntro&quot;,&quot;分数对比&quot;); map.put(&quot;praiseText&quot;,&quot;评价&quot;); // 从集合获取poiid String poiid = poiidList.get(index); index++; // jackson ObjectMapper mapper = new ObjectMapper(); // 获取酒店详细信息的 url poiid 不同 String url = &quot;https://ihotel.meituan.com/group/v1/poi/&quot; + poiid +&quot;?utm_medium=touch&amp;version_name=999.9&amp;platformid=1&amp;start=1559606400000&amp;end=1559692800000&amp;mypos=40.043888%2C116.340587&amp;cityId=1&amp;subtype=0&amp;type=1&amp;isRecommend=0&amp;recType=0&amp;isLocal=1&amp;entryType=2&amp;fields=phone%2CscoreSource%2CmarkNumbers%2CcityId%2Caddr%2Clng%2ChasGroup%2CsubwayStationId%2Ccates%2CfrontImg%2CchooseSitting%2Cwifi%2CavgPrice%2Cstyle%2CfeatureMenus%2CavgScore%2Cname%2CparkingInfo%2Clat%2CcateId%2Cintroduction%2CshowType%2CareaId%2CdistrictId%2Cpreferent%2ClowestPrice%2CcateName%2CareaName%2CzlSourceType%2CcampaignTag%2CmallName%2CmallId%2CbrandId%2CbrandName%2CbrandLogo%2CbrandStory%2CsmPromotion%2Cktv%2Cgeo%2ChistoryCouponCount%2Crecommendation%2CiUrl%2CisQueuing%2CnewPayInfo%2CpayInfo%2CsourceType%2Cabstracts%2CgroupInfo%2CisSuperVoucher%2Cdiscount%2CisWaimai%2CcollectionDeals%2CnearPoi%2Csparkle%2CtopicList%2CcityIds%2CshowChannel%2CshowStatus&amp;_token=eJyNUl2PqkgQ%2FS88%2BDJeaegGmknMRlARxNERRfHmxvAp3yA0Kt7sf9%2BembuZ7Nt2Ol1VpytVdU73b6bRA%2BaVA3ShIXMLG%2BaV4UZgJDJDhrT0RhBkkeM5CUMoDBn%2FP5gMIBgyXmNPmdefnCDxQw5I4q8PaEuRnxIWhwLEv4bfHo%2Fo%2FsjQaQITE1K3ryybjIowIZ1bjvyqYN17zcYCG1ckzNm6StggdPNRTIr8LxrpwZjjZBkAUcaDlrgN2SVFOP4cCojogwkYhGXwjco8%2FkJ9cqYFxoBDvAgkGSFBkkQJYojARxYnAwmIgOd4iDhRPPvgHCJEUZ7HiEeSCEWMJeHsll2enyvuHHyOSEsS9%2BKdM6oiPyB9TdsOnvk8dy9j0nQhVfJ%2F8MyTlnweX0T9hPSUqSAO%2FDj0M70c84CTfwDxB0Bf0Loj35gwyF0yRmAEEMQYD%2FLyQlUSR5SZgKWB69N%2BRRW4JKnK3deEbdWQcVtQ%2FRj6HsWOvge12R%2Fr%2FrHk33hFPwZl0iaXknqh8Zjv23nHPycr9uSHkaova8D3sqHslPtdaZOl173AVW%2B%2BE1vR3%2FaH5hJFoOp8G2eTeBctnrfsGGl1d9wvnv6bsuNgJ0YywOvYPLEv1nEuHA%2BOuEmtqRFEpn9CaKansaXA0p1c8KMJj9IS7xXbae%2BmuEErXZ%2FhK%2BwXmdYHvmfmUD1Ny0pFa0PRPV0%2FQaxqp2Te1a2Vu41XuvfLmk0Nu5nn0ju6VLO7sE%2Bj5eG97lx0v%2Bhq6Mwd9VA6ywnaTG1T42L72EMt2K0rYxWpRJ2o69go28YKtF1crrOLaywV34dZs%2BVNa3JTPLDn1urtcLePmv72sk07zX487ck6uiYPvUJTOxGn7K24pttiH4RVLzyOsyk2PLO0Okxu%2Fps%2BNTYWIP3z0J6UXb%2B3e28K1zW5LoI4Ao5mL4S8b63mXXIMM98JLNwsI8MWbONUZSvDqTnTss0W7yO44mfYTuJlLjebhyLKmuqEYdXdXBvoBX9fxLHKGZjLsqy8AmEpaxt333IyLNXZKrU7%2FS5Y%2FCZ%2FTtzAq127FPA1LWCaC2XeafDGv8AUHdXJ83BiWSkmAfJvqXMlouzwWaoWwRZ67PEUbDk%2BIZrXEK%2BUFN7dTzxnzPz9D8DyZ0c%3D&quot;; System.out.println(&quot;第&quot;+ index + &quot;家开始爬取&quot;); // 一共有2596条数据， 简单的跳出 // 如果不跳出，会报错，并且之前生成的excel会崩溃，别问我为什么知道 if (index &gt; 2595) { return; } // 很重要， 忽略接收对象中不存在的属性 mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // okhttp OkHttpClient okHttpClient = new OkHttpClient(); final Request request = new Request.Builder() .url(url) .build(); final Call call = okHttpClient.newCall(request); // 同步请求 new Thread(new Runnable() { @Override public void run() { try { Response response = call.execute(); InitialJson initData = mapper.readValue(response.body().string(), InitialJson.class); List&lt;PoiidResult&gt; hotelInfos = initData.getData(); String sheetName = &quot;美团酒店信息&quot;; long start = System.currentTimeMillis(); PoiidResult result = hotelInfos.get(0); // 本来计划改一下之前数据处理那部分，但搞不定，程序一停，数据就回滚了，暂时没发现哪的原因 // ExcelUtils.excelExport(hotelInfos, map, sheetName); // 找到了另一个写入excel的方法 FileInputStream fileInputStream = new FileInputStream(&quot;D:\\excel\\output1.xls&quot;); //获取excel信息 POIFSFileSystem poifsFileSystem = new POIFSFileSystem(fileInputStream); //得到文档对象 HSSFWorkbook workbook = new HSSFWorkbook(poifsFileSystem); //根据name获取sheet表 HSSFSheet sheet = workbook.getSheetAt(0); //获取第一行 HSSFRow row = sheet.getRow(0); // 找到目标xls文件 FileOutputStream out = new FileOutputStream(&quot;D:\\excel\\output1.xls&quot;); // 重点 获取最后一行 + 1 row = sheet.createRow((short)(sheet.getLastRowNum() + 1)); // 列对应的数据 row.createCell(0).setCellValue(result.getPoiid()); row.createCell(1).setCellValue(result.getName()); row.createCell(2).setCellValue(result.getPhone()); row.createCell(3).setCellValue(result.getShowType()); row.createCell(4).setCellValue(result.getAvgScore()); row.createCell(5).setCellValue(result.getScoreIntro()); row.createCell(6).setCellValue(result.getUseRuleIdentity()); row.createCell(7).setCellValue(result.getAddr()); row.createCell(8).setCellValue(result.getPraiseText()); row.createCell(9).setCellValue(result.getUseRuleTime()); row.createCell(10).setCellValue(result.getHotelStar()); row.createCell(11).setCellValue(result.getAreaName()); row.createCell(12).setCellValue(result.getFrontImg()); row.createCell(13).setCellValue(result.getIntroduction()); row.createCell(14).setCellValue(result.getLat()); row.createCell(15).setCellValue(result.getLng()); out.flush(); workbook.write(out); out.close(); long end = System.currentTimeMillis(); System.out.println(&quot;耗时：&quot;+(end-start)+&quot;ms&quot;); }catch (Exception e) { e.printStackTrace(); } } }).start(); } 还有个问题就是，数据越多会越慢，可以手动停一下，然后修改index继续爬。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven Pom.xml详解]]></title>
    <url>%2F2019%2F05%2F24%2FMaven-Pom-xml%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[史上最全的Maven Pom文件标签详解 &lt;span style=&quot;padding:0px; margin:0px&quot;&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。坐标包括group ID,atifactID和version。--&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符--&gt; &lt;artifactId/&gt; &lt;!--被继承的父项目的全球唯一标识符--&gt; &lt;groupId/&gt; &lt;!--被继承的父项目的版本--&gt; &lt;version/&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。--&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用--&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。--&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt; &lt;maven/&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字，--&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL--&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息--&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum--&gt; &lt;system/&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt; &lt;url/&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt; &lt;notifier&gt; &lt;!--传送通知的途径--&gt; &lt;type/&gt; &lt;!--发生错误时是否通知--&gt; &lt;sendOnError/&gt; &lt;!--构建失败时是否通知--&gt; &lt;sendOnFailure/&gt; &lt;!--构建成功时是否通知--&gt; &lt;sendOnSuccess/&gt; &lt;!--发生警告时是否通知--&gt; &lt;sendOnWarning/&gt; &lt;!--不赞成使用。通知发送到哪里--&gt; &lt;address/&gt; &lt;!--扩展配置项--&gt; &lt;configuration/&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt; &lt;inceptionYear/&gt; &lt;!--项目相关邮件列表信息--&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt; &lt;mailingList&gt; &lt;!--邮件的名称--&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL--&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表--&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息--&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符--&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名--&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email--&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL--&gt; &lt;url/&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织--&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL--&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等--&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表--&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素--&gt; &lt;contributor&gt; &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt; &lt;license&gt; &lt;!--license用于法律上的名称--&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL--&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息--&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt; &lt;tag/&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt; &lt;organization&gt; &lt;!--组织的全名--&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL--&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;sourceDirectory/&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt; &lt;scriptSourceDirectory/&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;testSourceDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。--&gt; &lt;outputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。--&gt; &lt;testOutputDirectory/&gt; &lt;!--使用来自该项目的一系列构建扩展--&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。--&gt; &lt;extension&gt; &lt;!--构建扩展的groupId--&gt; &lt;groupId/&gt; &lt;!--构建扩展的artifactId--&gt; &lt;artifactId/&gt; &lt;!--构建扩展的版本--&gt; &lt;version/&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt; &lt;defaultGoal/&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt; &lt;targetPath/&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt; &lt;filtering/&gt; &lt;!--描述存放资源的目录，该路径相对POM路径--&gt; &lt;directory/&gt; &lt;!--包含的模式列表，例如**/*.xml.--&gt; &lt;includes/&gt; &lt;!--排除的模式列表，例如**/*.xml--&gt; &lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录--&gt; &lt;directory/&gt; &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。--&gt; &lt;finalName/&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt; &lt;filters/&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt; &lt;extensions/&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息--&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id/&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase/&gt; &lt;!--配置的执行目标--&gt; &lt;goals/&gt; &lt;!--配置是否被传播到子POM--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表--&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt; &lt;id/&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志--&gt; &lt;activeByDefault/&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt; &lt;jdk/&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字--&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;)--&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本--&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt; &lt;property&gt; &lt;!--激活profile的属性的名称--&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值--&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。--&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。--&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素--&gt; &lt;build&gt; &lt;defaultGoal/&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素--&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports/&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素--&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素--&gt; &lt;properties/&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt; &lt;modules/&gt; &lt;!--发现依赖和扩展的远程仓库列表。--&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息--&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载--&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled/&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt; &lt;updatePolicy/&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt; &lt;checksumPolicy/&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称--&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID--&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID--&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。--&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt; &lt;excludeDefaults/&gt; &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。--&gt; &lt;outputDirectory/&gt; &lt;!--使用的报表插件和他们的配置。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息--&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--报表插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的报表插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--报表插件的配置--&gt; &lt;configuration/&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到--&gt; &lt;id/&gt; &lt;!--产生报表集合时，被使用的报表的配置--&gt; &lt;configuration/&gt; &lt;!--配置是否被继承到子POMs--&gt; &lt;inherited/&gt; &lt;!--这个集合里使用到哪些报表--&gt; &lt;reports/&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt; &lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt; &lt;layout/&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion/&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout/&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息--&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称--&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt; &lt;downloadUrl/&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt; &lt;relocation&gt; &lt;!--构件新的group ID--&gt; &lt;groupId/&gt; &lt;!--构件新的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--构件新的版本号--&gt; &lt;version/&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt; &lt;message/&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--&gt; &lt;status/&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt; &lt;properties/&gt; &lt;/project&gt; &lt;/span&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简称解释]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%AE%80%E7%A7%B0%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[云连接网（Cloud Connect Network, CCN）是智能接入网关的另一个重要组成部分。云连接网是由阿里云分布式接入网关组成的设备接入矩阵。您可以将云连接网绑定到云企业网，实现线下接入矩阵和云上中心矩阵全连接。路由器（VRouter）是专有网络的枢纽。作为专有网络中重要的功能组件，它可以连接VPC内的各个交换机，同时也是连接VPC和其他网络的网关设备。每个专有网络创建成功后，系统会自动创建一个路由器。每个路由器关联一张路由表。更多信息，参见路由交换机（VSwitch）是组成专有网络的基础网络设备，用来连接不同的云产品实例。创建专有网络之后，您可以通过创建交换机为专有网络划分一个或多个子网。同一专有网络内的不同交换机之间内网互通。您可以将应用部署在不同可用区的交换机内，提高应用的可用性。交换机(Switch)是一种基于MAC（网卡的硬件地址）识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。交换机分为：二层交换机，三层交换机或是更高层的交换机。三层交换机同样可以有路由的功能，而且比低端路由器的转发速率更快。它的主要特点是：一次路由，多次转发。路由器(Router)亦称选径器，是在网络层实现互连的设备。它比网桥更加复杂，也具有更大的灵活性。路由器有更强的异种网互连能力，连接对象包括局域网和广域网。过去路由器多用于广域网，由于路由器性能有了很大提高，价格下降到与网桥接近，因此在局域网互连中也越来越多地使用路由器。路由器是一种连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。路由器有两大典型功能，即数据通道功能和控制功能。数据通道功能包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成；控制功能一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等。RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。虚拟局域网扩展（Virtual Extensible LAN, VXLAN）是一种网络虚拟化技术，它试图改善大云计算部署相关的可扩展性问题。它采用类似VLAN封装技术封装基于MAC含括第 4 层的UDP数据包的 OSI 第2层 以太网帧 ，使用 4789 作为默认分配的 IANA 目的地 UDP 端口号。[zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2F2019%2F05%2F22%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[定时任务和日志]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[定时任务案例 log4j.properties简单配置 Quartz介绍 log4j.properties详细配置]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL中concat以及group_concat]]></title>
    <url>%2F2019%2F02%2F25%2FMYSQL%E4%B8%ADconcat%E4%BB%A5%E5%8F%8Agroup-concat%2F</url>
    <content type="text"><![CDATA[百度百科 一、concat()函数 1、功能：将多个字符串连接成一个字符串。 2、语法：concat(str1, str2,…) 返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 二、concat_ws()函数 1、功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符～（concat_ws就是concat with separator） 2、语法：concat_ws(separator, str1, str2, …) 说明：第一个参数指定分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null。 三、group_concat()函数 前言：在有group by的查询语句中，select指定的字段要么就包含在group by语句的后面，作为分组的依据，要么就包含在聚合函数中。（有关group by的知识请戳：浅析SQL中Group By的使用）。 1、功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 2、语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] ) 说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals()小区别]]></title>
    <url>%2F2019%2F01%2F30%2Fequals-%E5%B0%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[java中””.equals(str)与str.equals(“”)一样吗？ 不一样，如果str为nullstr = null;str.equals(“”)会抛异常 –&gt;nullPointerException如果写为 “”.equals(str) –&gt;可以防止nullPointerException]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cron表达式]]></title>
    <url>%2F2019%2F01%2F25%2FCron%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转自 cron表达式详解 （cron = “ “) cron表达式格式： {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}例 “0 0 12 ? * WED” 在每星期三下午12:00 执行（年份通常 省略） 一：每个字段的允许值字段 允许值 允许的特殊字符秒 0-59 , - /分 0-59 , - /小时 0-23 , - /日期 1-31 , - ? / L W C月份 1-12 或者 JAN-DEC , - /星期 1-7 或者 SUN-SAT , - ? / L C #年（可选） 留空, 1970-2099 , - * / 二：允许值的意思：Seconds (秒) ：可以用数字0－59 表示， Minutes(分) ：可以用数字0－59 表示， Hours(时) ：可以用数字0-23表示, Day-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份 Month(月) ：可以用0-11 或用字符串 “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示 Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示 三：每个符号的意义： 表示所有值；? 表示未说明的值，即不关心它为何值； 表示一个指定的范围；, 表示附加一个可能值；/ 符号前表示开始时间，符号后表示每次递增的值；L(“last”) (“last”) “L” 用在day-of-month字段意思是 “这个月最后一天”；用在 day-of-week字段, 它简单意思是 “7” or “SAT”。 如果在day-of-week字段里和数字联合使用，它的意思就是 “这个月的最后一个星期几” – 例如： “6L” means “这个月的最后一个星期五”. 当我们用“L”时，不指明一个列表值或者范围是很重要的，不然的话，我们会得到一些意想不到的结果。 W(“weekday”) 只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个 月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日。 只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。 C 指和calendar联系后计算过的值。例：在day-of-month 字段用“5C”指在这个月第5天或之后包括calendar的第一天；在day-of-week字段用“1C”指在这周日或之后包括calendar的第一天。 四：一些cron表达式案例*/5 * * * * ? 每隔5秒执行一次 0 */1 * * * ? 每隔1分钟执行一次 0 0 5-15 * * ? 每天5-15点整点触发 0 0/3 * * * ? 每三分钟触发一次 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0 12 ? * WED 表示每个星期三中午12点 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 0 23 L * ? 每月最后一天23点执行一次 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 * * ? 2005 2005年的每天上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 &quot;30 * * * * ?&quot; 每半分钟触发任务 &quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务 &quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务 &quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务 &quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务 &quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务 &quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务 &quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务 &quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务 &quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务 &quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次 &quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次 &quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次 &quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务 &quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务 &quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务 &quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务 &quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务 五：表达式生成器有很多的cron表达式在线生成器 http://cron.qqe2.com/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[云连接网（Cloud Connect Network, CCN）是智能接入网关的另一个重要组成部分。云连接网是由阿里云分布式接入网关组成的设备接入矩阵。您可以将云连接网绑定到云企业网，实现线下接入矩阵和云上中心矩阵全连接。 不知道从什么时候开始，变得很少说话，变得不去发说说，变得默默承受一些事情，变得]]></content>
  </entry>
  <entry>
    <title><![CDATA[OSI参考模型]]></title>
    <url>%2F2018%2F12%2F19%2FOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[来自百度百科 #OSI参考模型OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。 #分层 第7层应用层：OSI中的最高层。为特定类型的网络应用提供了访问OSI环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。它包括：文件传送访问和管理FTAM、虚拟终端VT、事务处理TP、远程数据库访问RDA、制造报文规范MMS、目录服务DS等协议；应用层能与应用程序界面沟通，以达到展示给用户的目的。 在此常见的协议有:HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。第6层表示层：主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩与终端类型的转换。第5层会话层：在两个节点之间建立端连接。为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层4中处理双工方式 ；会话层管理登入和注销过程。它具体管理两个用户和进程之间的对话。如果在某一时刻只允许一个用户执行一项特定的操作，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一组数据。第4层传输层：—常规数据递送－面向连接或无连接。为会话层用户提供一个端到端的可靠、透明和优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务；传输层把消息分成若干个分组，并在接收端对它们进行重组。不同的分组可以通过不同的连接传送到主机。这样既能获得较高的带宽，又不影响会话层。在建立连接时传输层可以请求服务质量，该服务质量指定可接受的误码率、延迟量、安全性等参数，还可以实现基于端到端的流量控制功能。第3层网络层：本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。它包括通过互连网络来路由和中继数据 ；除了选择路由之外，网络层还负责建立和维护连接，控制网络上的拥塞以及在必要的时候生成计费信息。第2层数据链路层：在此层将数据分帧，并处理流控制。屏蔽物理层，为网络层提供一个数据链路的连接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输（差错控制）。本层指定拓扑结构并提供硬件寻址。常用设备有网桥、交换机；第1层物理层：处于OSI参考模型的最底层。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传送比特流。常用设备有（各种物理设备）网卡、集线器、中继器、调制解调器、网线、双绞线、同轴电缆。数据发送时，从第七层传到第一层，接收数据则相反。上三层总称应用层，用来控制软件方面。下四层总称数据流层，用来管理硬件。除了物理层之外其他层都是用软件实现的。数据在发至数据流层的时候将被拆分。在传输层的数据叫段，网络层叫包，数据链路层叫帧，物理层叫比特流，这样的叫法叫PDU（协议数据单元） #各层功能 (1)物理层(Physical Layer)物理层是OSI参考模型的最低层，它利用传输介质为数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送比特流，物理链路可能是铜线、卫星、微波或其他的通讯媒介。它关心的问题有：多少伏电压代表1？多少伏电压代表0？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。(2)数据链路层(Data Link Layer)数据链路层是为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧。数据帧中包含物理地址（又称MAC地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。(3)网络层(Network Layer)网络层是为传输层提供服务的，传送的协议数据单元称为数据包或分组。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。(4)传输层(Transport Layer)传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。传输层传送的协议数据单元称为段或报文。(5)会话层(Session Layer)会话层主要功能是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。(6)表示层(Presentation Layer)表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。(7)应用层(Application Layer)应用层是OSI参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP与TCP区别]]></title>
    <url>%2F2018%2F11%2F28%2FUDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[UDP协议定义：User Datagram Protocol，用户数据报协议主要作用：将网络数据压缩成数据包的形式数据包格式：一个二进制数据的传输单位工作机制：蛮干型 它想传送时就简单地去抓取来自应用程序的数据，并尽可能地把它扔到网络上。因此，在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端UDP把每个消息段放在队列中，应用程序每次从队列中读取一个消息段。优势：速度快，较安全与TCP协议相比UDP协议排除了信息可靠传递机制，也就是减少了TCP协议中提供数据包分组、组装和排序的过程需要的时间消耗。其次，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。劣势：可靠性差UDP协议是一种无连接的传输协议，排除信息可靠传递机制带来速度优势的同时，显然降低了可靠性的需求，也就是UDP协议无法得知其是否安全，完整到达的。应用因为UDP的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。在生活中音频、视频和普通数据都可以采用UDP协议来进行数据传输，比如腾讯QQ这些社交软件也多采用UDP。 TCP协议TCP：Transmission Control Protocol传输控制协议主要作用：把数据流分割成适当长度的报文段之后进行传输工作机制：紧小细微型面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据包之前必须先建立一个TCP链接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在一个TCP连接中，仅有两方彼此进行通信。而UDP更像是发短信，将发送方所有的信息一股脑儿全扔到网络中。优势：可靠性好1.当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。当TCP收到发自TCP连接另一端的数据，它将发送一个确认。TCP有延迟确认的功能，在此功能没有打开，则是立即确认。功能打开，则由定时器触发确认时间点。2.TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发送端超时并重发）3.既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。4.TCP的接收端必须丢弃重复的数据5.量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接受端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。劣势：速度慢，占用系统资源高，易被攻击TCP在传递数据之前，要先建连接，这会消耗时间，而在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间。由于在每台设备上都需要维护所有的传输连接，而每个连接都会占用系统的CPU、内存等硬件资源。此外，由于TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。应用当对网络通讯质量有要求的时候，比如：整个数据都要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如下：浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Tenlnet、SSH QQ文件传输……]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间的八种通信方式]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%AB%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转自https://www.cnblogs.com/wust221/p/5414839.html 进程间的八种通信方式–共享内存是最快的IPC方式1.无名管道（pipe）:管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。2.高级管道（popen）:将另一个程序当作一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们称为高级管道方式。3.有名管道（named pipe）：有名管道也是半双工的通信方式，但它允许无亲缘关系进程间的通信。4.消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。5.信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不用线程之间的同步手段。6.信号（sinal）：信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生。7.共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但多个进程都可以访问。==共享内存是最快的IPC方式==，他是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。8.套接字（socket）：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于==不同机器间的进程通信==。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile,lock和synchronized]]></title>
    <url>%2F2018%2F11%2F24%2Fvolatile-lock%E5%92%8Csynchronized%2F</url>
    <content type="text"><![CDATA[个人认为关键的几句话 volatile,它能够使变量在值发生改变时能尽快地让其他线程知道。 Lock不是Java语言内置的，synchronized是Java语言的关键字。 Lock是一个类，通过这个类可以实现同步访问。 synchronized不需要用户去手动释放锁，当synchronized方法或代码块执行完后，系统会自动让线程释放对锁的占用； Lock则必须用户手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[renren-fast开源框架]]></title>
    <url>%2F2018%2F11%2F23%2Frenren-fast%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[人人社区官方文档（删减版）https://www.renren.io/guide#data 今天在投递简历的时候遇到这样一家公司，出了一个面试前的作业，内容如下。 请使用开源框架renren-security或renren-fast/renren-fastplus，实现一个简单demo： 至少三个数据库表（表之间存在依赖关系）； 前端以列表框的形式展示可选内容（至少关联两个表）； 前端选中后，后台处理（至少涉及三个表）； 前端所采用的技术不限（但推荐优先使用vue.js）。 企业版 https://github.com/sunlightcs/renren-security人人开源社区 http://www.renren.io/open/码云后端源码 http://git.oschina.net/babaio/renren-fastgithub后端源码 https://github.com/zhaoqicheng/renren-fast/ 记一下这两天踩过的坑，万一以后用这个框架，能有点印象。 介绍项目描述 renren-fast 是一个轻量级的 Spring Boot 快速开发平台，能快速开发项目完善的 XSS 防范及脚本过滤，彻底杜绝 XSS 攻击，实现前后端分离，通过 token 进行数据交互（简单来说急速构建一个项目） 准备 前端源码 https://gitee.com/renrenio/renren-fast-vue后端源码 https://gitee.com/renrenio/renren-fast代码生成器 https://gitee.com/renrenio/renren-generator 开始后端部署环境要求 JDK1.8、MySQL5.5+利用git，在一个空文件夹下载renren-fast源码，如下 git initgit clone https://gitee.com/renrenio/renren-fast用idea打开项目 创建数据库renren_fast，数据库编码为UTF-8 在该库下运行项目中db/mysql.sql文件，初始化数据 修改application-dev.yml，更新MySQL账号密码 右键pom.xml选择Add as Maven Project 在pom.xml中更新依赖jar包，reimport 找到启动类io.renren.RenrenApplication.java，运行启动项目 访问以下两个地址 Swagger路径：http://localhost:8080/renren-fast/swagger/index.htmlSwagger注释路径：http://localhost:8080/renren-fast/swagger-ui.html 如上页面表示后端启动成功 前端部署 renren-fast-vue基于vue、element-ui构建开发，实现renren-fast后台管理前端功能， 提供一套更优的前端解决方案。欢迎star或fork前端Git库，方便日后寻找，及二次开发。 开发环境，需要安装node8.x最新版，尽量使用淘宝镜像利用git，在一个空文件夹下载renren-fast-vue源码，如下 git init //初始化git clone https://gitee.com/renrenio/renren-fast-vue //克隆项目cnpm install //安装依赖记得切到项目内运行cnpm run dev //启动服务生成环境，打包并把dist目录文件部署到nginx中cnpm run build //构建生产环境（默认）cnpm run build –qa //构建测试环境cnpm run build –uat //构建验收环境cnpm run build –prod //构建生产环境 不懂为什么要构建这么多安装nginx，并配置nginx.conf server { listen 80; server_name localhost; location / { root D:\\dist; index index.html index.htm; } } 登录的账号密码： admin / admin 配置文件主要注意端口号是否重复与路径application.yml # Tomcat server: tomcat: uri-encoding: UTF-8 max-threads: 1000 min-spare-threads: 30 port: 8080 connection-timeout: 5000ms servlet: context-path: /renren-fast application-dev.yml spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.jdbc.Driver druid: first: #数据源1 url: jdbc:mysql://localhost:3306/renren_fast?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 1234 数据交互 一般情况下，web项目都是通过session进行认证，每次请求数据时，都会把jsessionid放在cookie中，以便与服务端保持会话本项目是前后端分离的，通过token进行认证（登录时，生成唯一的token凭证），每次请求数据时，都会把token放在header中，服务端解析token，并确定用户身份及用户权限，数据通过json交互数据交互流程：不太懂 项目实战功能描述 我们来完成一个商品的列表、添加、修改、删除功能，熟悉如何快速开发自己的业务功能模块。 我们建一个表，tb_goods CREATE TABLE tb_goods ( goods_id bigint NOT NULL AUTO_INCREMENT, name varchar(50) COMMENT ‘商品名’, intro varchar(500) COMMENT ‘介绍’, price decimal(10,2) COMMENT ‘价格’, num int COMMENT ‘数量’, PRIMARY KEY (goods_id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=’商品管理’; 接下来，我们利用代码生成器，帮我们生成代码 代码生成器Git地址：https://gitee.com/renrenio/renren-generator 代码生成器打开项目，配置好以后访问 localhost默认80端口在数据库renren_fast中，执行建表语句，创建tb_goods表，再启动renren-generator项目(运行RenrenApplication.java的main方法即可) 我们只需勾选tb_goods，点击【生成代码】按钮，则可生成相应代码，如下所示： 测试项目我们先在renren_fast库中，执行goods_menu.sql语句，这个SQL是生成菜单的，SQL语句如下所示： -- 菜单SQL INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) VALUES (&apos;1&apos;, &apos;商品管理&apos;, &apos;modules/generator/goods.html&apos;, NULL, &apos;1&apos;, &apos;fa fa-file-code-o&apos;, &apos;6&apos;); -- 按钮父菜单ID set @parentId = @@identity; -- 菜单对应按钮SQL INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;查看&apos;, null, &apos;goods:list,goods:info&apos;, &apos;2&apos;, null, &apos;6&apos;; INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;新增&apos;, null, &apos;goods:save&apos;, &apos;2&apos;, null, &apos;6&apos;; INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;修改&apos;, null, &apos;goods:update&apos;, &apos;2&apos;, null, &apos;6&apos;; INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;删除&apos;, null, &apos;goods:delete&apos;, &apos;2&apos;, null, &apos;6&apos;; 执行完以后可以到数据库中查看表sys_menu确认是否生成 注意生成代码的同时会生成vue，只需要将 main\resources\src\views\modules\generator 该路径下的generator粘贴到vue中对应的modules中即可生成前端页面 然后把生成的main目录覆盖renren-fast的main目录，再重启renren-fast，效果如下所示： 修改代码实现一对一查询（如员工带职业属性）需要一个新的对象 //省略get,set，构造器 public class EmpVoct { private Integer empId; private String empName; private Integer voctId; //添加对应的职业对象 private VoctEntity voctEntity; public EmpVoct() { } } EmpMapper.xml &lt;resultMap id=&quot;EmpVoct&quot; type=&quot;io.renren.modules.generator.entity.EmpVoct&quot;&gt; &lt;result property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt; &lt;result property=&quot;voctId&quot; column=&quot;voct_id&quot;/&gt; &lt;association property=&quot;voctEntity&quot; column=&quot;voct_id&quot; select=&quot;io.renren.modules.generator.dao.VoctDao.selectVoctById&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;empVoct&quot; resultMap=&quot;EmpVoct&quot;&gt; select emp_id,v.voct_id,emp_name,voct_name from emp e inner join voct v on e.voct_id = v.voct_id &lt;/select&gt; EmpDao层 @Mapper public interface EmpDao extends BaseMapper&lt;EmpEntity&gt; { int deleteByVoctIds(Integer[] voctIds); List&lt;EmpVoct&gt; empVoct(); } EmpServiceImpl @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) { /*Page&lt;EmpEntity&gt; page = this.selectPage( new Query&lt;EmpEntity&gt;(params).getPage(), new EntityWrapper&lt;EmpEntity&gt;() );*/ Page&lt;EmpVoct&gt; page = new Query&lt;EmpVoct&gt;(params).getPage(); List&lt;EmpVoct&gt; list = baseMapper.empVoct(); page.setRecords(list); return new PageUtils(page); } 前端部分注意开发时，如何连接后台项目api接口？实现前后端对接。修改/static/config/index.js目录文件中 window.SITE_CONFIG[‘baseUrl’] = ‘本地api接口请求地址’; 开发时，如何解决跨域？ 转自https://blog.csdn.net/zd1007129657/article/details/82698854 修改/config/dev.env.js目录文件中OPEN_PROXY: true开启代理修改/config/index.js目录文件中proxyTable对象target: ‘代理api接口请求地址’重启本地服务 需要注意的时，默认的target地址是不能改的，因为他对应的是renren-fast的后台接口，你要想能正常返回结果查看项目演示，就得用人家这个地址（虽然项目跑起来了，界面也看到了，但对于咱们来说没有任何吊用，看第二种方法） 使用mockJs，调用本地模拟数据 值得注意的是，文档上写的是默认开启，但代码中并非全为true，而是false，之所以路径错误，原因就在于此，mockJs本地模拟数据没有开启，收到将对应的代码全改为true，重启项目，一切ok]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>renren-fast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的基本了解]]></title>
    <url>%2F2018%2F11%2F13%2Fredis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.redis是什么？redis是一种支持Key-Value等多种数据结构的存储系统。可用于缓存、时间发布或订阅、高速队列等场景。该数据库使用ANSIC语言编写，支持网络，提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。 2.支持的语言ActionScript Bash C C# C++ Clojure Common Lisp Crystal D Dart Elixir emacs lisp Erlang Fancy gawk GNU Prolog Go Haskell Haxe Io Java JavaScript Julia Lua Matlab mruby Nim Node.js Objective-C OCanl Pascal Perl PHP Pure Data Python R Racket Rebol Ruby Rust Scala Scheme Smalltalk Swift Tcl VB VCL 3.redis的应用场景有哪些？1.会话缓存（最常用）2.消息队列，比如支付3.活动排行榜或计数4.发布、订阅消息（消息通知）5.商品列表、评论列表等 4.redis数据类型Redis一共支持五种数据类：string(字符串)、hash(哈希)、list(列表)、set(集合)和zset(sorted set 有序集合)。Key:redis本质上是一个key-value数据库，所以我们首先来看看它的key。首先key也是字符串类型，由于key不是binarysafe的字符串，所以像”my key”和”myken\n”这样包含空格和换行的key是不允许的。 1.string(字符串)它是redis最基本的数据类型，一个key对应一个value，而且string类型是二进制安全的。redis的string可以包含任何数据。包括jpg图片或者序列化的对象。最大上限是512Mb字节。如果只用string类型，redis就可以被看作加上持久化特性的memcached 127.0.0.1:6379&gt;set key &quot;hello world&quot; OK //表示成功 127.0.0.1:6379&gt;get key &quot;hello world&quot; //根据key获取value 127.0.0.1:6379&gt;mset key1 &quot;hi&quot; key2 &quot;nihao&quot; key3 &quot;hello&quot; OK //多个key-value同时存储 127.0.0.1:6379&gt;get key1 &quot;hi&quot; //分别获取value验证 127.0.0.1:6379&gt;get key2 &quot;nihao&quot; 127.0.0.1:6379&gt;get key3 &quot;hello&quot; 127.0.0.1:6379&gt;mget key1 key2 nonexisting 1)&quot;hi&quot; //一次获取多个key的值 2)&quot;nihao&quot; 3)(nil) //若key不存在返回nil 2.hash(哈希)redis hash 是一个键值对的集合，是一个string类型的field和value的映射表，适合用于存储对象。 127.0.0.1:6379&gt;hset redishash 1 &quot;001&quot; (integer) 1 127.0.0.1:6379&gt;hget redishash 1 &quot;001&quot; 127.0.0.1:6379&gt;hmset redishash 1 &quot;001&quot; 2 &quot;002&quot; OK 127.0.0.1:6379&gt;hget redishash 1 &quot;001&quot; 127.0.0.1:6379&gt;hget redishash 2 &quot;002&quot; 127.0.0.1:6379&gt;hmget redishash 1 2 1)&quot;001&quot; 2)&quot;002&quot; 3.list(列表)是redis简单的字符串列表，它按插入顺序排序。每一个子元素都是string类型的双向链表。我们可以通过push，pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。 127.0.0.1:6379&gt;lpush word hi (integer)1 //返回1表示成功，0表示key存在且不是list类型 127.0.0.1:6379&gt;lpush word hello (integer)2 127.0.0.1:6379&gt;lpush word world (integer)3 127.0.0.1:6379&gt;lrange word 0 2 1)&quot;hello&quot; 2)&quot;hi&quot; 3)&quot;world&quot; 127.0.0.1:6379&gt;llen word (integer)3 4.set(集合)是string类型的无序集合，不可重复。set元素最大可以包含(2的32次方-1)个元素。set的是通过hash table实现的，hash table会随着添加或者删除自动的调整大小。关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取并集(union)，交集(intersection),差集(difference)。通过这些操作可以很容易的实现sns中的好友推荐和blog的tag功能。 127.0.0.1:6379&gt;sadd redis redisset (integer)1 127.0.0.1:6379&gt;sadd redis redisset1 (integer)1 127.0.0.1:6379&gt;sadd redis redisset2 (integer)1 127.0.0.1:6379&gt;smembers redis 1)&quot;redisset1&quot; 2)&quot;redisset&quot; 3)&quot;redisset2&quot; 127.0.0.1:6379&gt;sadd redis redisset2 (integer)0 127.0.0.1:6379&gt;smembers redis 1)&quot;redisset1&quot; 2)&quot;redisset&quot; 3)&quot;redisset2&quot; 127.0.0.1:6379&gt;srem redis redisset (integer)1 127.0.0.1:6379&gt;smembers redis 1)&quot;redisset1&quot; 2)&quot;redisset2&quot; 5.zset(sorted set 有序集合)是string类型的有序集合，也不可重复sorted set中的每个元素都会关联一个double类型的score。sorted set的实现是skip list 和hash table的混合体。当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，另一个score到元素的映射被添加到skip并按照score排序，所以就可以有序的获取集合中的元素。根据分数对元素进行升序排序，如果多个元素有相同的分数，则以字典顺序进行升序排序，sorted set 因此非常适合实现排名。 127.0.0.1:6379&gt;zadd nosql 0 001 (integer)1 127.0.0.1:6379&gt;zadd nosql 0 002 (integer)1 127.0.0.1:6379&gt;zadd nosql 0 003 (integer)1 127.0.0.1:6379&gt;zcount nosql 0 0 (integer)3 127.0.0.1:6379&gt;zcount nosql 0 3 (integer)3 127.0.0.1:6379&gt;zrem nosql 002 (integer)1 127.0.0.1:6379&gt;zcount nosql 0 3 (integer)2 127.0.0.1:6379&gt;zscore nosql 003 &quot;0&quot; 127.0.0.1:6379&gt;zrangebyscore nosql 0 10 1)&quot;001&quot; 2)&quot;003&quot; 127.0.0.1:6379&gt;zadd nosql 1 003 (integer)0 127.0.0.1:6379&gt;zadd nosql 1 004 (integer)1 127.0.0.1:6379&gt;zrangebyscore nosql 0 10 1)&quot;001&quot; 2)&quot;004&quot; 3)&quot;003&quot; 127.0.0.1:6379&gt;zadd nosql 3 005 (integer)1 127.0.0.1:6379&gt;zadd nosql 2 006 (integer)1 127.0.0.1:6379&gt;zrangebyscore nosql 0 10 1)&quot;001&quot; 2)&quot;003&quot; 3)&quot;004&quot; 4)&quot;006&quot; 5)&quot;005&quot; 5.redis服务相关的命令127.0.0.1:6379&gt;select 0 OK 127.0.0.1:6379&gt;info #Server -------省略N行 select #选择数据库（数据库编号0-15）quit #退出连接info #获得服务的信息与统计monitor #实时监控config get #获得服务配置flushdb #删除当前选择的数据库中的keyflushall #删除所有数据库中的key 6.redis的发布与订阅redis发布与订阅(pub/sub)是它的一种消息通信模式，一方发送消息，一方接受信息。下图是三个客户端同时订阅同一个频道下图是有新信息发送给频道1时。就会将消息发送给订阅它的三个客户端 7.redis持久化redis持久有两种方式:Snapshotting(快照),Append-only file(AOF) Snapshotting(快照) 1、将存储在内存的数据以快照的方式写入二进制文件中，如默认dump.rdb中2、save 900 1 //900秒内如果超过1个Key被修改，则启动快照保存3、save 300 10 //300秒内如果超过10个Key被修改，则启动快照保存4、save 60 10000 //60秒内如果超过10000个Key被修改，则启动快照保存 Append-only file(AOF) 1、使用AOF持久时，服务会将每个收到的写命令通过write函数追加到文件中（appendonly.aof）2、AOF持久化存储方式参数说明appendonly yes //开启AOF持久化存储方式appendfsync always //收到写命令后就立即写入磁盘，效率最差，效果最好appendfsync everysec //每秒写入磁盘一次，效率与效果居中appendfsync no //完全依赖OS，效率最佳，效果没法保证 8.redis性能测试自带相关测试工具 [root@text ~]redis-benchmark --help 实际测试勇士执行100万的请求 [root@text ~]redis-benchmark -n 1000000 -q]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map集合]]></title>
    <url>%2F2018%2F11%2F12%2FMap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Map集合：Hashtable:底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。HashMap:底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。代替了Hashtable。TreeMap:底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。 Map集合存储和Collection有着很大不同：Collection一次存一个元素；Map一次存一对元素。Collection是单列集合；Map是双列集合。Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应（映射）关系。特点：要保证map集合中键的唯一性。 1.添加。 put(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。void putAll(Map);2.删除。void clear()：清空value remove(key) ：删除指定键。3.判断。boolean isEmpty()：boolean containsKey(key)：是否包含keyboolean containsValue(value) ：是否包含value4.取出。int size()：返回长度value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。Collection values()：获取map集合中的所有的值。5.想要获取map中的所有元素：原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。 把map集合转成set的方法： Set keySet(); Set entrySet();//取的是键和值的映射关系。 Entry就是Map接口中的内部接口；为什么要定义在map内部呢?entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。 遍历Map集合的四种方法 public static void main(String[] args){ Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(“1”,”value1”); map.put(“2”,”value2”); map.put(“3”,”value3”); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value: &quot;); for(String key : map.keySet()){ System.out.println(&quot;key=&quot; + key + &quot;and value&quot; + map.get(key)); } } //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value: &quot;); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = map,entrySet().iterator(); while(it.hasNext()){ Map.Entry&lt;String,String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot;and value = &quot; + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){ System.out.println(&quot;key= &quot; + entry.getKty() + &quot;and value = &quot; + entey.getValue()); } //第四种 System.out.println(&quot;通过Map.values()遍历所有的value,但布不能遍历key&quot;); for(String v : map.values()){ System.out.println(&quot;value= &quot; + v); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set接口]]></title>
    <url>%2F2018%2F11%2F12%2FSet%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种。迭代器。HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；HashSet集合保证元素唯一性：通过元素的hashCode方法，和Equals方法完成的。当元素的hashCode 值相同时，才继续判断元素的equals是否为true。如果为true，那么视为相同元素，不存。如果为false，那么存储。如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。LinkedHashSet:有序，hashSet的子类。TreeSet:对Set集合中元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。 哈希表的原理：1.对对象元素中的关键字（对象中的特有数据），进行哈希算法的运算，并得出一个具体的算法值，这个值称为哈希值。2.哈希值就是这个元素的位置。3.如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础+1顺延。4.存储哈希值的结构，我们称为哈希表。5.存储哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。 对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。 TreeSet:用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。如果元素不具备比较性，在运行时会发生ClassCastException异常。所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。 注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。 TreeSet集合排序有两种方式，Comparable和Comparator区别：1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。第二种方式较为灵活。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口]]></title>
    <url>%2F2018%2F11%2F12%2FList%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习LIst体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最在的特点。 List:有序（元素存入集合的顺序和取出的顺序一致），元素都有索引。元素可以重复。 ArrayList：底层的数据结构是数组，线程不同步，ArrayList替代了Vector，查询元素的速度非常快。 LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。 Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都很慢。 1.添加：add(index,element) ：在指定的索引位插入元素。addAll(index,collection) ：在指定的索引位插入一堆元素。2.删除：remove(index) ：删除指定索引位的元素。 返回被删的元素。3.获取：Object get(index) ：通过索引获取指定元素。int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回-1；所以，通过-1，可以判断一个元素是否存在。int lastIndexOf(Object o) ：反向索引指定元素的位置。List subList(start,end) ：获取子列表。4.修改：Object set(index,element) ：对指定索引位进行元素的修改。5.获取所有元素：ListIterator listIterator()：list集合特有的迭代器。 List集合支持对元素的增、删、改、查。List集合因为有下标有了自己的获取元素的方式：遍历。 for(int x=0; x&lt;list.size(); x++){ sop(&quot;get:&quot;+list.get(x)); } 注意：在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。导致的原因是：集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。如何解决呢？既然是在迭代中对元素进行操作，找迭代器的方法最为合适。可是Iterator中只有hasNext,next,remove方法。通过查询它的子接口，ListIerator，发现该列表迭代器接口具备了对元素的增、删、改、查的动作。 ListIterator是List集合特有的迭代器。 ListIterator it = list.listIterator;//取代Iterator it = list.iterator; 返回值 方法 void add(E e)将指定的元素插入列表（可选操作）。 boolean hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。 boolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。 E next() 返回列表中的下一个元素。 int nextIndex() 返回对 next 的后续调用所返回元素的索引。 E previous() 返回列表中的前一个元素。 int previousIndex() 返回对 previous 的后续调用所返回元素的索引。 void remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。 void set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。 可变长度数组的原理：当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。ArratList：构造一个初始容量为10的空列表。是按照原数组的50%延长（jdk1.8之前为50% + 1）。Vector:是按照原数组的100%延长。 注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。 LinkedList：的特有方法。addFirst();addLast();在jdk1.6以后。offerFirst();offerLast(); getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;getLast();在jdk1.6以后。peekFirst();获取链表中的第一个元素。如果链表为空，返回null。peekLast(); removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementExceptionremoveLast();在jdk1.6以后。pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。pollLast();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator接口]]></title>
    <url>%2F2018%2F11%2F12%2FIterator%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[迭代器：是一个接口。作用：用于取集合中的元素。 返回值 方法 boolean hasNext()如果仍有元素可以迭代，则返回true。 E next()返回迭代的下一个元素。 void remove()从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作） 每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。也就是说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。 Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是什么不重要。这对象肯定符合一个规则Iterator接口。 public static void main(String[] args){ Collection coll = new ArrayList(); coll.add(&quot;abc0&quot;); coll.add(&quot;abc1&quot;); coll.add(&quot;abc2&quot;); } //遍历 Iterator it = coll.iterator(); while(it.hasNext()){ System.out.println(it.next()); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection接口]]></title>
    <url>%2F2018%2F11%2F12%2FCollection%2F</url>
    <content type="text"><![CDATA[Collection:List:有序（元素存入集合的顺序和取出的顺序一致），元素都有索引。元素可以重复。Set:无序（存入和取出顺序有可能不一致），不可以存储重复元素。必须保证元素唯一性。1.添加：add(object)：添加一个元素addAll(Collection) ：添加一个集合中的所有元素。2.删除：clear()：将集合中的元素全删除，清空集合。remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。3.判断：boolean contains(obj) ：集合中是否包含指定元素。boolean containsAll(Collection) ：集合中是否包含指定的多个元素。boolean isEmpty()：集合中是否有元素。4.获取：int size()：集合中有几个元素。5.取交集：boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。6.获取集合中所有元素：Iterator iterator()：迭代器7.将集合变成数组：toArray(); 使用集合的技巧：看到Arry就是数组结构，有角标，查询速度很快。看到link就是链表结构，增删速度快，而且有特有方法。addFirst;addLast;removeFirst();removeLast();getFirst();getLast();看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构中的元素必须覆盖hashCode,equals方法。看到tree就是二叉树，就要想到排序，就要用到比较。比较的两种方式：一个是Comparable:覆盖compareTo方法；一个是Comparator:覆盖compare方法。LinkedHashSet,LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。 集合什么时候用？当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。 保证唯一，就用Set。不保证唯一，就用List。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[doGet()与doPost()]]></title>
    <url>%2F2018%2F11%2F10%2FdoGet-%E4%B8%8EdoPost%2F</url>
    <content type="text"><![CDATA[Get与Post都是向服务器传数据在Servlet中doPost方法里还调用了doGet方法(doGet(request,response))所以在创建Servlet时可以不要doPost方法，通常情况下二者没区别。建议：1.涉及传密用Post数据提交。2.数据查询用Get方式；数据添加、修改或删除时，用Post方式。使用表单时，如果不指定method，默认为Get方式。区别： 1.生成方式Get有三种：（1）直接在URL地址栏中输入（2）网页中的超链接（3）form中method为get或不设置methodPost一种：form中method为post 2.数据传输方式Get方式：表单数据存放在URL地址后面。所有Get方式提交时HTTP中没有消息体Post方式：表单数据存放在HTTP协议的消息体中以实体方式传送到服务器。 3.服务器获取数据方式Get方式：服务器采用request.QueryString来获取变量的值。Post方式：服务器采用request.Form来获取数据。 4.传送的数据量Get方式：数据量长度有限制，一般不超过2kb,因为是参数传递，且在地址中，故数据量有限制。Post方式：适合大规模的数据传送，因为是以实体的方式传送的。 5.安全性Get方式：安全性差，因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。Post方式：安全性较高，因为Post方式提交数据时采用的HTTPpost机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到action所指的URL中，用户是看不见的。 6.在用户刷新时Get方式：不会有任何提示Post方式：会弹出提示框，问用户是否重新提交。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet生命周期和创建方式]]></title>
    <url>%2F2018%2F11%2F10%2FServlet-%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Servletservlet是运行在Web服务器中的小型Java程序（即，服务器端的小应用程序）。servlet通常通过Http（超文本传输协议）接受和响应来自Web客户端的请求。这个servlet不用new，就是一个Java类，可以直接使用，用来处理请求响应的。写一个Java类实现servlet接口。重写未实现的方法。其实最关键的一个就是service()方法。 Servlet的生命周期（重要）四个过程1.加载和实例化当Servlet容器启动或客户端发送一个请求时，Serlvet容器会查找内存中是否存在该Serlvet实例，若存在，则直接读取该实例响应请求；如果不存在就创建一个Servlet实例。2.init初始化实例化后，Servlet将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）3.service服务，每次被访问都会被调用初始化后，Servlet处于能响应请求的就绪状态。当接受到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求，转调不同的doXXX方法。4.destroy销毁当Servlet容器关闭时，Servlet实例也随时销毁，其间，Servlet容器会调用Servlet的destroy()方法去判断该Servlet是否应当被释放（或回收资源） Servlet执行过程：1.先写一个类实现Servlet接口。2.然后现在web.xml中配置上面第二步中：创建一个servlet实例 &lt;!-- 创建一个Servlet实例 --&gt; &lt;servlet&gt; &lt;!--3.servlet的内部名称--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--4.servlet的类全名：包名加简单类名--&gt; &lt;servlet-class&gt;com.itheima.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; 这个标签其实就是new这个servlet类，底层代码其实就是classforName，因为Tomcat功能可以解析xml，所以可以这么写servlet-mapping: &lt;!-- 给Servlet提供（映射）一个可供客户端访问的URL --&gt; &lt;servlet-mapping&gt; &lt;!--2.servlet的映射内部名称，通过他可以找到上面的servlet的内部名称--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--1.请求servlet的映射路径--&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 一定记得加一个/，否则就是访问localhost:8080/demo1，而不是localhost:8080/项目名/demo1，通过这个映射地址找到servlet类。 原理解释： 三步走：1.客户端首先通过地址访问demo下的北荣，tomcat会找到对应的项目。2.然后会通过web.xml找到url-pattern下为 /demo的标签，然后找到兄弟标签servlet-name对应的servletDemo。3.最后找到对应的servlet类，之后就会调用该类下的service()方法。 第一种创建方式：写一个类实现servlet接口，重写5个方法。 import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 第二种创建方式：继承javax.servlet.GenericServlet类（适配器模式），实现service方法 import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; public class ServletDemo2 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } } 第三种创建方式（最常用）：使用方法：创建一个类然后继承HttpServlet类，重写doGet，doPost方法。 import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); } } 对于错误信息： HTTP Status 405 - HTTP method GET is not supported by this URL type Status report message HTTP method GET is not supported by this URL description The specified HTTP method is not allowed for the requested resource. Apache Tomcat/7.0.75 原因是在覆盖doPost或者doGet的时候忘记去掉super.doGet或者super.doPost了，去掉就好了。 补充三种创建方式的关系： Servlet –&gt; GenericServlet –&gt; HttpServlet（继承HttpServlet）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目经验]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[项目名称： 飞机大战项目简介： 该项目主要采用面向对象的思想，通过构建对象实现接口和多线程实时刷新，在JFrame窗体中利用Graphics类在画板上生成和移除，实现了飞机大战的基本玩法，加入了血量，火力升级，积分，敌方飞机的不同轨道以及BOSS独特的攻击模式。 项目名称： 员工管理系统项目简介： 该项目主要采用了Spring,SpringMVC,Mybatis框架和MySQL,JQuery,AJax等为主要技术。项目主要功能为注册，登录进入管理界面，可以对部门、员工进行增删改查，结果利用Page分页显示，利用session记录登录状态，利用cookie实现免登录，验证码利用Graphics生成并添加定时器，提供模糊查找的功能。 项目名称： 饿了么外卖（移动端）项目简介： 该项目采用前后端分离开发，前端主要使用Vue+nginx+node.js。后端主要使用SpringBoot。前端部分展示商家信息，客户评价和商品信息，利用nginx反向代理到本地tomcat服务器。Vue的组件化开发,router实现界面内跳转，整体布局使用弹性布局，利用better-scroll插件实现滚动和联动。后端部分：提供了买家订单，订单详情，商品信息和商品类目的管理。利用SpringBoot生成一个web项目，进行yml的配置，根据Api文档考虑业务逻辑和代码逻辑。例如，买家订单id不能重复，利用系统时间加5位随机数。商品信息和商品类目的展示添加分页，增加和修改可以判断是否有id利用一个页面实现，捕捉异常跳转失败页面，时间的输出格式等。 项目名称： 搭建个人博客项目简述： 该项目是个人利用课余时间摸索搭建而成的个人博客，主要采用node.js,hexo,github为主要技术。项目主要功能为可以上传分享一些文章，展示个人简介，文章归档，标签，分类，归档，站内搜索，评论等功能。并使用个人域名解析实现个性域名。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目简单叙述]]></title>
    <url>%2F2018%2F11%2F08%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[项目名： 仿饿了么项目 项目描述： 采用前后端分离开发，前端主要使用Vue+nginx+node.js。后端主要使用SpringBoot。前端部分：展示了商家信息，客户评价和商品信息。利用nginx反向代理到本地tomcat。后端部分：提供了买家订单，订单详情，商品信息和商品类目的管理。 项目实现过程：前端部分：Vue的组件化开发，router路由实现界面跳转，页面布局使用弹性布局。商家信息的背景图片模糊化，公告弹层利用v-show，定位和层级。客户评价获取后台数据。商品信息较为复杂，利用better-scroll插件实现滚动效果和联动。在使用v-for遍历数据时加入index与计算属性绑定实现点击高亮效果。购物车根据商品数量与价格判断是否显示与滚动效果。后端部分：利用springboot生成一个项目，进行yml的配置，根据Api文档考虑业务逻辑和代码逻辑。买家订单id不能重复利用系统时间加5位随机数，根据订单状态判断是否需要取消，商品信息和商品类目的展示添加分页，增加和修改可以判断是否有id利用一个页面实现，捕捉异常跳转失败页面，时间的输出格式等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>springboot</tag>
        <tag>vue</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math ceil(),floor(),round()方法]]></title>
    <url>%2F2018%2F11%2F07%2FMath-ceil-floor-round-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Math.ceil()对一个数进行向上取整(个人理解向大转)使用方法 Math.ceil(x); 返回值：返回大于或等于x，并且与之最接近的整数。正数则把小数“入”，负数则把小数“舍”。例如： Math.ceil(1.2); //输出2 Math.ceil(1.8); //输出2 Math.ceil(-1.2); //输出-1 Math.ceil(-1.8); //输出-1 Math.floor()对一个数进行向下取整（个人理解向小转）使用方法 Math.floor(x); 返回值：返回小于或等于x并且与之最为接近的整数。正数则把小数“舍”，负数则把小数“入”。例如： Math.floor(1.2); //输出1 Math.floor(1.8); //输出1 Math.floor(-1.2); //输出-2 Math.floor(-1.8); //输出-2 Math.round()四舍五入取整使用方法 Math.round(x); 返回值：与x最接近的整数。 Math.floor(1.2); //输出1 Math.floor(1.8); //输出2 Math.floor(-1.2); //输出-1 Math.floor(-1.8); //输出-2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven远程仓库]]></title>
    <url>%2F2018%2F11%2F05%2FMaven%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Maven配置中央仓库maven作为一个项目管理工具确实为我们提供了很大的方便，但是在国内这个网络下对我们就不是很友好了，阿里云和华为云都为我们提供了中央仓库，个人推荐华为云，因为在学习SpringBoot时，出现了jar包缺少依赖的问题，而华为云没有。 本地仓库在这里先提一下修改本地仓库的储存路径，默认情况下maven会在用户目录下创建.m2/repository/的仓库目录，但一般情况下，我们不希望在C盘有过多的文件，我们需要在找到 \apache-maven\conf\settings.xml 打开，找到settings标签 &lt;settings&gt; //将默认仓库注释掉，添加自定义仓库路径 &lt;localRepository&gt;D:\Program Files\JAVA\mavenRepository&lt;/localRepository&gt; &lt;/settings&gt; 这样maven下载jar包的时候就会下载到自定义路径中 阿里云中央仓库修改远程仓库为阿里云中央仓库 还是在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 这样就配置成功了 华为云中央仓库修改远程仓库为华为云中央仓库 操作差不多，需要多加一步，先在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt; &lt;/mirror&gt; 还需要在servers标签中添加一个server &lt;servers&gt; &lt;server&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;username&gt;anonymous&lt;/username&gt; &lt;password&gt;devcloud&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 开始体验飞一般的下载速度吧！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的基本使用]]></title>
    <url>%2F2018%2F11%2F03%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git简介Git是目前世界上最先进的分布式版本控制系统。Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。 Git下载https://git-scm.com/downloads一路next就可以在桌面右键出现Git Bash here和Git GUI here就说明成功了 Git基本使用配置用户名，邮箱 git config –global user.email “你的邮箱”git config –global user.name “你的用户名” 这个是用来配置本地仓库的，可以随意填写 创建一个本地版本仓库接下来我们创建第一个仓库1.创建一个空白文件夹，目录不包含中文，右键Git Bash here，输入 git init 我们可以看到当前目录出现了一个.git目录（这是个默认隐藏的文件夹）2.创建一个hellogit.txt文件3.添加文件到本地仓库 git add hellogit.txtgit commit -m “文件描述” 这样我们就把这个文件添加到了本地仓库4.把文件中加一些文字，执行以下命令 git status 查看仓库当前状态，提示有文件被修改了，需要再次执行git add和git commit 版本回退1.打印日志 git log //查看提交历史git reflog //查看命令历史git reset –hard “” //填写你想回退的版本的id 2.查看当前状态 git status 3.删除命令 git rm “文件名”git commit -m “文件描述” 注意：提交到仓库的最好使用命令删除 远程仓库代码托管平台： 码云(gitee.com)：是开源中国社区团队推出的基于Git的快速的、免费的、稳定的在线代码托管平台，不限制私有库和公有库数量。有个缺点是使用page功能时自定义域名需要付费。 github(github.com)：是全球最大的开源社区，基于git的版本托管平台。私有库需要付费，访问速度慢。之前申请的号无故被封，还是得用~ 1.创建SSHkey，以github举例 ssh-keygen -t rsa -C “邮箱” 将此ssh添加到Github的个人设置中的SSH中 ssh -T git@github.com显示Hi，xxxxx就说明成功了 2.创建origin git remote add origin “远程仓库名” //添加远程仓库git remote -v //查看当前绑定仓库git remote remove “远程仓库名” //删除远程仓库 3.向远程仓库推送 git push -u origin mastergit pull origin master //同步远程仓库到本地 4.克隆仓库 git clone “远程仓库名”]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法(Hexo)]]></title>
    <url>%2F2018%2F11%2F02%2FMarkdown%E8%AF%AD%E6%B3%95-Hexo%2F</url>
    <content type="text"><![CDATA[转载：https://blog.csdn.net/zhuzhuyule/article/details/58347687?utm_source=blogxgwz2 Hexo下的Markdown语法Markdown时一种轻量级的标记语言，优点在于： 专注专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明描述分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， 文字 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 开头或， 使用`三个反引号 代码内容 三个反引号（Esc下边的键） 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt; ## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt; ### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt; #### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt; ##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt; ###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 内容强调加粗、斜体字体 **加粗** 显示 字体 *斜体* 显示 字体 ***加粗并斜体*** 显示 字体 __加粗__ 显示 字体 _斜体_ 显示 字体 ___加粗并斜体___ 显示 组合 *__加粗并斜体__* 显示 删除线~~删除一段文本~~ 高亮使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调 比如`突出背景色`来显示强调效果 引用显示标准使用 &gt; 每行开始都使用 &apos;&gt;&apos;； &gt; 引用**开始**； &gt; 引用**换行**； &gt; 引用**结束**。 &gt; 还在引用中！ 两个回车结束引用！ 省略使用 &gt; 仅第一行加应用； 引用开始； 引用换行； 引用结束； 两个回车结束引用,不在引用范围内了！ 表格表格语法： 列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 可以使用冒号来定义对齐方式： | 左对齐 | 右对齐 | 居中 | | :---- | ----:| :--: | 代码块*代码块语法遵循标准 markdown 代码，使用三个反引号开始，三个反引号结束 例如： 1234```JavaSystem.out.println(&quot;Hello World&quot;)``` 特别提示 如何在代码块中打出 三个反引号 实际上是使用 4个` 包含 3个` 就可以了，想表示更多，最外层+1就好了。 1234`````````````` 链接插入[博客]https://www.zwjblog.top 图片插入![我的头像]https://www.zwjblog.top/images/qqtouxiang.jpg 列表无序列表* *列表展示 * *列表展示 * *列表展示 + +列表展示 + +列表展示 + +列表展示 - -列表展示 - -列表展示 - -列表展示 效果如下： *列表展示 *列表展示 *列表展示 +列表展示 +列表展示 +列表展示 -列表展示 -列表展示 -列表展示 有序列表这种方式不用手动设置序号，自动生成列表序列 1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. 还是二级序列，没有三级序列 效果如下： 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 还是二级序列，没有三级序列 // //多于二级序列一个空格，仍然是二级序列 链接自动检测博客：https://www.zwjblog.top]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的基本理解]]></title>
    <url>%2F2018%2F11%2F02%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[主要参考https://www.cnblogs.com/lwbqqyumidi/p/3804883.html 线程(Thread类)、程序和进程关系：一个程序至少有一个进程，一个进程至少有一个线程。进程是程序在计算机上的一次执行活动，是资源分配的基本单位。线程是调度的基本单位，进程包含线程，线程共用进程的资源。进程是资源分配单位，线程是CPU调度单位。 一、线程的生命周期及五种基本状态这是一张比较经典的图片 Java线程具有五种基本状态新建状态（New）：当线程对象创建后，即进入了新建状态，如 Thread t = new MyThread();就绪状态（Runnable）：当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了start()此线程立即就会执行；运行状态（Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注意：就绪状态是进入到运行状态的唯一入口，也就是说，线程想要进入运行状态执行首先必须处于就绪状态中；阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；2.同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态；3.其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二、Java多线程的创建及启动Java中线程的创建常见有三种基本形式1.继承Thread类，重写该类的run()方法。 class MyThread extends Thread{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest{ public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30){ //创建一个新的线程myThread1此线程进入新建状态 Thread myThread1 = new MyThread(); //创建一个新的线程myThread2此线程进入新建状态 Thread myThread2 = new MyThread(); //调用start()方法使得线程进入就绪状态 myThread1.start(); //调用start()方法使得线程进入就绪状态 myThread2.start(); } } } } 输出的结果： main 0 ~ main 99 Thread-0 0 ~ Thread-0 99 Thread-0 0 ~ Thread-0 99 可以看出虽然当i == 30时，进入判断体，但是线程并没有马上执行，这取决于CPU的调度时机2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实体类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread独享才是真正的线程对象。 class MyRunnable implements Runnable{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest { public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } //创建一个Runnable实现类的对象 Runnable myRunnable = new MyRunnable(); //将myRunnable作为Thread target创建新的线程 Thread thread1 = new Thread(myRunnable); //调用start()方法使得线程进入就绪状态 thread1.start(); } } 与实现Runnable接口创建线程方式相似，不同的地方在于 Thread thread = new MyThread(myRunnable); public interface Runnable { public abstract void run(); } @Override public void run() { if (target != null) { target.run(); } } 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; { //.... } public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; { void run(); } 注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat]]></title>
    <url>%2F2018%2F11%2F02%2FSimpleDateFormat%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat的一些常用语法 转自http://www.cnblogs.com/qiangqiangqiang/p/7680752.html SimpleDateFormat函数语法注意大小写 G 年代标志符y 年M 月d 日h 时 在上午或下午 (1~12)H 时 在一天中 (0~23)m 分s 秒S 毫秒E 星期D 一年中的第几天F 一月中第几个星期几w 一年中第几个星期W 一月中第几个星期a 上午 / 下午 标记符k 时 在一天中 (1~24)K 时 在上午或下午 (0~11)z 时区 SimpleDateFormat aDate=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); SimpleDateFormat bDate=new SimpleDateFormat(&quot;yyyy-mmmmmm-dddddd&quot;); long now = System.currentTimeMillis(); 运行结果： 2018-11-02 14:40:482018-000040-000002 SimpleDateFormat myFmt=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); SimpleDateFormat myFmt1=new SimpleDateFormat(&quot;yy/MM/dd HH:mm&quot;); SimpleDateFormat myFmt2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//等价于now.toLocaleString() SimpleDateFormat myFmt3=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;); SimpleDateFormat myFmt4=new SimpleDateFormat( &quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;); 运行结果： 2018-11-02 14:41:552018-000041-0000022018年11月02日 14时41分55秒18/11/02 14:412018-11-02 14:41:552018年11月02日 14时41分55秒 星期五一年中的第 306 天 一年中第44个星期 一月中第1个星期 在一天中14时 CST时区 笔试题：求10天后的时间，并以”yyyy年MM月dd日”格式输出 import java.text.SimpleDateFormat; public class Test { public static void main(String[] args) { //格式化日期 SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //当前系统时间加上10天的时间，单位（毫秒） long tenday = System.currentTimeMillis() + 10 * 24 * 60 * 60 * 1000; //输出 System.out.println(date.format(tenday)); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目SpringBoot]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AESpringBoot%2F</url>
    <content type="text"><![CDATA[前端部分后补充 后端部分摘自老师的笔记 一、环境搭建和工具 所需环境：java,mysql,tomcat 使用工具：IDEA,Navicat 二、数据库的设计表设计 类目create table `product_category` ( `category_id` int not null auto_increment, `category_name` varchar(64) not null comment &apos;类目名字&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`category_id`) ); 商品create table `product_info` ( `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;单价&apos;, `product_stock` int not null comment &apos;库存&apos;, `product_description` varchar(64) comment &apos;描述&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `product_status` tinyint(3) DEFAULT &apos;0&apos; COMMENT &apos;商品状态,0正常1下架&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`product_id`) ); 订单create table `order_master` ( `order_id` varchar(32) not null, `buyer_name` varchar(32) not null comment &apos;买家名字&apos;, `buyer_phone` varchar(32) not null comment &apos;买家电话&apos;, `buyer_address` varchar(128) not null comment &apos;买家地址&apos;, `buyer_openid` varchar(64) not null comment &apos;买家微信openid&apos;, `order_amount` decimal(8,2) not null comment &apos;订单总金额&apos;, `order_status` tinyint(3) not null default &apos;0&apos; comment &apos;订单状态, 默认为新下单&apos;, `pay_status` tinyint(3) not null default &apos;0&apos; comment &apos;支付状态, 默认未支付&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`order_id`), key `idx_buyer_openid` (`buyer_openid`) ); 订单商品create table `order_detail` ( `detail_id` varchar(32) not null, `order_id` varchar(32) not null, `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;当前价格,单位分&apos;, `product_quantity` int not null comment &apos;数量&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`detail_id`), key `idx_order_id` (`order_id`) ); 卖家create table `seller_info` ( `id` varchar(32) not null, `username` varchar(32) not null, `password` varchar(32) not null, `openid` varchar(64) not null comment &apos;微信openid&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`id`) ) comment &apos;卖家信息表&apos;; 三、Api文档商品列表 GET /sell/buyer/product/list 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;name&quot;: &quot;热榜&quot;, &quot;type&quot;: 1, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;皮蛋粥&quot;, &quot;price&quot;: 1.2, &quot;description&quot;: &quot;好吃的皮蛋粥&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] }, { &quot;name&quot;: &quot;好吃的&quot;, &quot;type&quot;: 2, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123457&quot;, &quot;name&quot;: &quot;蛋糕&quot;, &quot;price&quot;: 10.9, &quot;description&quot;: &quot;美味爽口&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] } ] } 创建订单 POST /sell/buyer/order/create 参数 name: &quot;张三&quot; phone: &quot;13333333333&quot; address: &quot;西七道&quot; openid: &quot;ew3euwhd7sjw9diwkq&quot; //用户的微信openid items: [{ productId: &quot;1423113435324&quot;, productQuantity: 2 //购买数量 }] 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;147283992738221&quot; } } 订单列表 GET /sell/buyer/order/list 参数 openid: 18eu2jwk2kse3r42e2e page: 0 //从第0页开始 size: 10 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;orderId&quot;: &quot;161873371171128075&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }, { &quot;orderId&quot;: &quot;161873371171128076&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }] } 查询订单详情 GET /sell/buyer/order/detail 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;buyerName&quot;: &quot;李四&quot;, &quot;buyerPhone&quot;: &quot;15555555555&quot;, &quot;buyerAddress&quot;: &quot;西八道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 18, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490177352, &quot;updateTime&quot;: 1490177352, &quot;orderDetailList&quot;: [ { &quot;detailId&quot;: &quot;161899085974995851&quot;, &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;productId&quot;: &quot;157875196362360019&quot;, &quot;productName&quot;: &quot;招牌奶茶&quot;, &quot;productPrice&quot;: 9, &quot;productQuantity&quot;: 2, &quot;productIcon&quot;: &quot;http://xxx.com&quot;, &quot;productImage&quot;: &quot;http://xxx.com&quot; } ] } } 取消订单 POST /sell/buyer/order/cancel 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: null } 获取openid 重定向到 /sell/wechat/authorize 参数 returnUrl: http://xxx.com/abc //【必填】 返回 http://xxx.com/abc?openid=oZxSYw5ldcxv6H0EU67GgSXOUrVg 支付订单 重定向 /sell/pay/create 参数 orderId: 161899085773669363 returnUrl: http://xxx.com/abc/order/161899085773669363 返回 http://xxx.com/abc/order/161899085773669363 四、买家类目1.dao层需要的方法根据categoryType的集合来查询 2.service需要的方法根据id查询查询所有根据categoryType的集合来查询新增和更新 五、商品1.dao层需要的方法根据商品状态来查询 2.service层需要的方法根据id查询查询所有上架商品查询所有商品（给管理端使用，需要包含分页）增加和修改方法 3.买家端API的开发提供一个查询所有商品和类别的api接口（需要重新包装数据）]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>springboot</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F10%2F29%2Fspringboot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringBoot项目的构建有三种方式：一、手动构建利用maven构建一个普通的项目，我们手动去加入依赖。 1.在pom中引入父pom,代码如下&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.17.RELEASE&lt;/version&gt; &lt;/parent&gt; 2.引入SpringBoot依赖，代码如下&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3.加入编译插件&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4.写一个启动类@Controller //可以帮助SpringBoot应用将所有符合条件的@Configuration配置 都加载到当前SpringBoot创建并使用的IoC容器。 @EnableAutoConfiguration public class BootStarter { //servlet映射地址 @RequestMapping(&quot;/hello&quot;) //返回json格式的数据 @ResponseBody public String hello(){ return &quot;hello world&quot;; } public static void main(String[] args) { // SpringApplication.run(BootStarter.class,args); } } 5.运行main方法，在地址栏访问localhost:8080/hello . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.17.RELEASE) 启动成功！ 二、Spring官网Spring官网为我们提供了生成项目的方式访问https://start.spring.io/根据提示填写，下载解压使用IDEA将项目打开 三、利用IDEA工具新建项目直接选择Spring Initializr就可以生成一个Spring Boot项目（常用）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于node.js,hexo,github搭建博客]]></title>
    <url>%2F2018%2F10%2F29%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[基于 node.js+hexo+github 搭建一个属于自己的博客！ 前言&emsp;&emsp;从买阿里云服务器开始说起，开始研究服务器到底能做什么，最开始了解到云服务器可以是一台24小时运行的电脑，并且拥有自己的IP，就想着先把做的仿饿了么外卖项目放到服务器上运行，经过无数的踩坑，从linux系统都不会进到后面的关防火墙，配置安全组。再到搭建Node.js环境，git环境，连接github，终于让项目跑起来。再开始想怎样实现员工管理系统也能在服务器上运行，又开始配置JDK，Mysql，Tomcat环境，最后几经周折也实现了（虽然还有）一些BUG。 &emsp;&emsp;通过阿里云，又了解了域名相关，就想着自己是不是可以拥有一个属于自己的域名，比如说自定义的博客，也可以在服务器上跑（不能让它闲着–！），就开始在网上搜寻相关的知识。开始真的是一头雾水，别人是一步一个脚印，我感觉我是一步一个坑，最后摸索出用node.js+hexo+github 就可以实现我想要的结果，不容易不容易。 正题配置环境我们需要配置所需要的工具node.js+hexo+github这里就暂时不做过多解释，只给出检测的方法。在一个空文件夹下，右键Git Bash here node -version npm -version git -version 都能显示版本说明我们可以开始搭建了。 hexo初始化我们需要一个官方默认的hexo主题，在Git界面执行以下命令 hexo init 这是遇到的一个大坑，几KB每秒的下载速度，最后还卡住了，果断扔到服务器上下载。我上传到百度网盘，可以下载，下载后不需要执行上面的代码。 链接：https://pan.baidu.com/s/1QZSevQU6zkvJ55DnFUWQMQ提取码：m67r 接下来我们需要配置hexo和node依赖的包 npm install 这时我们可以查看hexo是否初始化 hexo -version 显示版本就说明hexo可以使用。 git部分git这部分，我们需要将此文件夹下的文件利用下面的代码先推到git中 git init git add -A git commit -m &quot;提交&quot; git remote add origin &quot;你的github仓库&quot; 这里需要注意的是：不要往仓库上推，仓库存的不是这部分文件，而是一些静态资源文件，比如html、css和js文件。 hexo主题生成清理静态资源文件 hexo clean 生成静态资源文件 hexo g 部署项目，通过localhost:4000访问 hexo s 页面出现Hexo，此时就说明成功了&emsp;&emsp;接下来的就比较简单了，打开hexo下的_config.yml文件，这个文件包含了hexo的站点配置，在最下方需要添加代码 deploy: type: git repo: &quot;这里填写你的github仓库&quot; branch: master &emsp;&emsp;这个时候千万不要用git pull或者git push等命令！应该使用 hexo clean hexo g hexo d hexo d这个命令就可以把你的项目提交到你的github仓库中。 github网址生成&emsp;&emsp;github对我们很友好（吐槽下真的很慢），为我们提供了一个功能，生成了一个网址可以展示仓库中的项目，但这个功能需要手动开启，打开我们的github，找到对应的仓库，找到Setting选项下的GitHub Pages，选择Source中你项目的分支，一般是主分支。实在不行开个翻译，很好找，点击保存后，这样就会显示一个网址，这样就可以访问了。注意：项目名需要xxx.github.io的格式，还需要在_config.yml中找到以下代码。 url: &quot;你生成的网址&quot; root: /项目名 结束语&emsp;&emsp;仔细回想一下，其实挺简单的，主要是什么都不知道，还有没想到的以后再进行补充，欢迎留言评论。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
