<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UDP与TCP区别]]></title>
    <url>%2F2018%2F11%2F28%2FUDP%E4%B8%8ETCP%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[UDP协议定义：User Datagram Protocol，用户数据报协议主要作用：将网络数据压缩成数据包的形式数据包格式：一个二进制数据的传输单位工作机制：蛮干型 它想传送时就简单地去抓取来自应用程序的数据，并尽可能地把它扔到网络上。因此，在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端UDP把每个消息段放在队列中，应用程序每次从队列中读取一个消息段。优势：速度快，较安全与TCP协议相比UDP协议排除了信息可靠传递机制，也就是减少了TCP协议中提供数据包分组、组装和排序的过程需要的时间消耗。其次，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。劣势：可靠性差UDP协议是一种无连接的传输协议，排除信息可靠传递机制带来速度优势的同时，显然降低了可靠性的需求，也就是UDP协议无法得知其是否安全，完整到达的。应用因为UDP的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。在生活中音频、视频和普通数据都可以采用UDP协议来进行数据传输，比如腾讯QQ这些社交软件也多采用UDP。 TCP协议TCP：Transmission Control Protocol传输控制协议主要作用：把数据流分割成适当长度的报文段之后进行传输工作机制：紧小细微型面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据包之前必须先建立一个TCP链接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在一个TCP连接中，仅有两方彼此进行通信。而UDP更像是发短信，将发送方所有的信息一股脑儿全扔到网络中。优势：可靠性好1.当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。当TCP收到发自TCP连接另一端的数据，它将发送一个确认。TCP有延迟确认的功能，在此功能没有打开，则是立即确认。功能打开，则由定时器触发确认时间点。2.TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发送端超时并重发）3.既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。4.TCP的接收端必须丢弃重复的数据5.量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接受端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。劣势：速度慢，占用系统资源高，易被攻击TCP在传递数据之前，要先建连接，这会消耗时间，而在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间。由于在每台设备上都需要维护所有的传输连接，而每个连接都会占用系统的CPU、内存等硬件资源。此外，由于TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。应用当对网络通讯质量有要求的时候，比如：整个数据都要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如下：浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Tenlnet、SSH QQ文件传输……]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间的八种通信方式]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%AB%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转自https://www.cnblogs.com/wust221/p/5414839.html 进程间的八种通信方式–共享内存是最快的IPC方式1.无名管道（pipe）:管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。2.高级管道（popen）:将另一个程序当作一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们称为高级管道方式。3.有名管道（named pipe）：有名管道也是半双工的通信方式，但它允许无亲缘关系进程间的通信。4.消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。5.信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不用线程之间的同步手段。6.信号（sinal）：信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生。7.共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但多个进程都可以访问。==共享内存是最快的IPC方式==，他是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。8.套接字（socket）：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于==不同机器间的进程通信==。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile,lock和synchronized]]></title>
    <url>%2F2018%2F11%2F24%2Fvolatile-lock%E5%92%8Csynchronized%2F</url>
    <content type="text"><![CDATA[个人认为关键的几句话 volatile,它能够使变量在值发生改变时能尽快地让其他线程知道。 Lock不是Java语言内置的，synchronized是Java语言的关键字。 Lock是一个类，通过这个类可以实现同步访问。 synchronized不需要用户去手动释放锁，当synchronized方法或代码块执行完后，系统会自动让线程释放对锁的占用； Lock则必须用户手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[renren-fast开源框架]]></title>
    <url>%2F2018%2F11%2F23%2Frenren-fast%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[人人社区官方文档（删减版）https://www.renren.io/guide#data 今天在投递简历的时候遇到这样一家公司，出了一个面试前的作业，内容如下。 请使用开源框架renren-security或renren-fast/renren-fastplus，实现一个简单demo： 至少三个数据库表（表之间存在依赖关系）； 前端以列表框的形式展示可选内容（至少关联两个表）； 前端选中后，后台处理（至少涉及三个表）； 前端所采用的技术不限（但推荐优先使用vue.js）。 企业版 https://github.com/sunlightcs/renren-security人人开源社区 http://www.renren.io/open/码云后端源码 http://git.oschina.net/babaio/renren-fastgithub后端源码 https://github.com/zhaoqicheng/renren-fast/ 记一下这两天踩过的坑，万一以后用这个框架，能有点印象。 介绍项目描述 renren-fast 是一个轻量级的 Spring Boot 快速开发平台，能快速开发项目完善的 XSS 防范及脚本过滤，彻底杜绝 XSS 攻击，实现前后端分离，通过 token 进行数据交互（简单来说急速构建一个项目） 准备 前端源码 https://gitee.com/renrenio/renren-fast-vue后端源码 https://gitee.com/renrenio/renren-fast代码生成器 https://gitee.com/renrenio/renren-generator 开始后端部署环境要求 JDK1.8、MySQL5.5+利用git，在一个空文件夹下载renren-fast源码，如下 git initgit clone https://gitee.com/renrenio/renren-fast用idea打开项目 创建数据库renren_fast，数据库编码为UTF-8 在该库下运行项目中db/mysql.sql文件，初始化数据 修改application-dev.yml，更新MySQL账号密码 右键pom.xml选择Add as Maven Project 在pom.xml中更新依赖jar包，reimport 找到启动类io.renren.RenrenApplication.java，运行启动项目 访问以下两个地址 Swagger路径：http://localhost:8080/renren-fast/swagger/index.htmlSwagger注释路径：http://localhost:8080/renren-fast/swagger-ui.html 如上页面表示后端启动成功 前端部署 renren-fast-vue基于vue、element-ui构建开发，实现renren-fast后台管理前端功能， 提供一套更优的前端解决方案。欢迎star或fork前端Git库，方便日后寻找，及二次开发。 开发环境，需要安装node8.x最新版，尽量使用淘宝镜像利用git，在一个空文件夹下载renren-fast-vue源码，如下 git init //初始化git clone https://gitee.com/renrenio/renren-fast-vue //克隆项目cnpm install //安装依赖记得切到项目内运行cnpm run dev //启动服务生成环境，打包并把dist目录文件部署到nginx中cnpm run build //构建生产环境（默认）cnpm run build –qa //构建测试环境cnpm run build –uat //构建验收环境cnpm run build –prod //构建生产环境 不懂为什么要构建这么多安装nginx，并配置nginx.conf server { listen 80; server_name localhost; location / { root D:\\dist; index index.html index.htm; } } 登录的账号密码： admin / admin 配置文件主要注意端口号是否重复与路径application.yml # Tomcat server: tomcat: uri-encoding: UTF-8 max-threads: 1000 min-spare-threads: 30 port: 8080 connection-timeout: 5000ms servlet: context-path: /renren-fast application-dev.yml spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.jdbc.Driver druid: first: #数据源1 url: jdbc:mysql://localhost:3306/renren_fast?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 1234 数据交互 一般情况下，web项目都是通过session进行认证，每次请求数据时，都会把jsessionid放在cookie中，以便与服务端保持会话本项目是前后端分离的，通过token进行认证（登录时，生成唯一的token凭证），每次请求数据时，都会把token放在header中，服务端解析token，并确定用户身份及用户权限，数据通过json交互数据交互流程：不太懂 项目实战功能描述 我们来完成一个商品的列表、添加、修改、删除功能，熟悉如何快速开发自己的业务功能模块。 我们建一个表，tb_goods CREATE TABLE tb_goods ( goods_id bigint NOT NULL AUTO_INCREMENT, name varchar(50) COMMENT ‘商品名’, intro varchar(500) COMMENT ‘介绍’, price decimal(10,2) COMMENT ‘价格’, num int COMMENT ‘数量’, PRIMARY KEY (goods_id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=’商品管理’; 接下来，我们利用代码生成器，帮我们生成代码 代码生成器Git地址：https://gitee.com/renrenio/renren-generator 代码生成器打开项目，配置好以后访问 localhost默认80端口在数据库renren_fast中，执行建表语句，创建tb_goods表，再启动renren-generator项目(运行RenrenApplication.java的main方法即可) 我们只需勾选tb_goods，点击【生成代码】按钮，则可生成相应代码，如下所示： 测试项目我们先在renren_fast库中，执行goods_menu.sql语句，这个SQL是生成菜单的，SQL语句如下所示： -- 菜单SQL INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) VALUES (&apos;1&apos;, &apos;商品管理&apos;, &apos;modules/generator/goods.html&apos;, NULL, &apos;1&apos;, &apos;fa fa-file-code-o&apos;, &apos;6&apos;); -- 按钮父菜单ID set @parentId = @@identity; -- 菜单对应按钮SQL INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;查看&apos;, null, &apos;goods:list,goods:info&apos;, &apos;2&apos;, null, &apos;6&apos;; INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;新增&apos;, null, &apos;goods:save&apos;, &apos;2&apos;, null, &apos;6&apos;; INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;修改&apos;, null, &apos;goods:update&apos;, &apos;2&apos;, null, &apos;6&apos;; INSERT INTO `sys_menu` (`parent_id`, `name`, `url`, `perms`, `type`, `icon`, `order_num`) SELECT @parentId, &apos;删除&apos;, null, &apos;goods:delete&apos;, &apos;2&apos;, null, &apos;6&apos;; 执行完以后可以到数据库中查看表sys_menu确认是否生成 注意生成代码的同时会生成vue，只需要将 main\resources\src\views\modules\generator 该路径下的generator粘贴到vue中对应的modules中即可生成前端页面 然后把生成的main目录覆盖renren-fast的main目录，再重启renren-fast，效果如下所示： 修改代码实现一对一查询（如员工带职业属性）需要一个新的对象 //省略get,set，构造器 public class EmpVoct { private Integer empId; private String empName; private Integer voctId; //添加对应的职业对象 private VoctEntity voctEntity; public EmpVoct() { } } EmpMapper.xml &lt;resultMap id=&quot;EmpVoct&quot; type=&quot;io.renren.modules.generator.entity.EmpVoct&quot;&gt; &lt;result property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt; &lt;result property=&quot;voctId&quot; column=&quot;voct_id&quot;/&gt; &lt;association property=&quot;voctEntity&quot; column=&quot;voct_id&quot; select=&quot;io.renren.modules.generator.dao.VoctDao.selectVoctById&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;empVoct&quot; resultMap=&quot;EmpVoct&quot;&gt; select emp_id,v.voct_id,emp_name,voct_name from emp e inner join voct v on e.voct_id = v.voct_id &lt;/select&gt; EmpDao层 @Mapper public interface EmpDao extends BaseMapper&lt;EmpEntity&gt; { int deleteByVoctIds(Integer[] voctIds); List&lt;EmpVoct&gt; empVoct(); } EmpServiceImpl @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) { /*Page&lt;EmpEntity&gt; page = this.selectPage( new Query&lt;EmpEntity&gt;(params).getPage(), new EntityWrapper&lt;EmpEntity&gt;() );*/ Page&lt;EmpVoct&gt; page = new Query&lt;EmpVoct&gt;(params).getPage(); List&lt;EmpVoct&gt; list = baseMapper.empVoct(); page.setRecords(list); return new PageUtils(page); } 前端部分注意开发时，如何连接后台项目api接口？实现前后端对接。修改/static/config/index.js目录文件中 window.SITE_CONFIG[‘baseUrl’] = ‘本地api接口请求地址’; 开发时，如何解决跨域？ 转自https://blog.csdn.net/zd1007129657/article/details/82698854 修改/config/dev.env.js目录文件中OPEN_PROXY: true开启代理修改/config/index.js目录文件中proxyTable对象target: ‘代理api接口请求地址’重启本地服务 需要注意的时，默认的target地址是不能改的，因为他对应的是renren-fast的后台接口，你要想能正常返回结果查看项目演示，就得用人家这个地址（虽然项目跑起来了，界面也看到了，但对于咱们来说没有任何吊用，看第二种方法） 使用mockJs，调用本地模拟数据 值得注意的是，文档上写的是默认开启，但代码中并非全为true，而是false，之所以路径错误，原因就在于此，mockJs本地模拟数据没有开启，收到将对应的代码全改为true，重启项目，一切ok]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>renren-fast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的基本了解]]></title>
    <url>%2F2018%2F11%2F13%2Fredis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.redis是什么？redis是一种支持Key-Value等多种数据结构的存储系统。可用于缓存、时间发布或订阅、高速队列等场景。该数据库使用ANSIC语言编写，支持网络，提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。 2.支持的语言ActionScript Bash C C# C++ Clojure Common Lisp Crystal D Dart Elixir emacs lisp Erlang Fancy gawk GNU Prolog Go Haskell Haxe Io Java JavaScript Julia Lua Matlab mruby Nim Node.js Objective-C OCanl Pascal Perl PHP Pure Data Python R Racket Rebol Ruby Rust Scala Scheme Smalltalk Swift Tcl VB VCL 3.redis的应用场景有哪些？1.会话缓存（最常用）2.消息队列，比如支付3.活动排行榜或计数4.发布、订阅消息（消息通知）5.商品列表、评论列表等 4.redis数据类型Redis一共支持五种数据类：string(字符串)、hash(哈希)、list(列表)、set(集合)和zset(sorted set 有序集合)。Key:redis本质上是一个key-value数据库，所以我们首先来看看它的key。首先key也是字符串类型，由于key不是binarysafe的字符串，所以像”my key”和”myken\n”这样包含空格和换行的key是不允许的。 1.string(字符串)它是redis最基本的数据类型，一个key对应一个value，而且string类型是二进制安全的。redis的string可以包含任何数据。包括jpg图片或者序列化的对象。最大上限是512Mb字节。如果只用string类型，redis就可以被看作加上持久化特性的memcached 127.0.0.1:6379&gt;set key &quot;hello world&quot; OK //表示成功 127.0.0.1:6379&gt;get key &quot;hello world&quot; //根据key获取value 127.0.0.1:6379&gt;mset key1 &quot;hi&quot; key2 &quot;nihao&quot; key3 &quot;hello&quot; OK //多个key-value同时存储 127.0.0.1:6379&gt;get key1 &quot;hi&quot; //分别获取value验证 127.0.0.1:6379&gt;get key2 &quot;nihao&quot; 127.0.0.1:6379&gt;get key3 &quot;hello&quot; 127.0.0.1:6379&gt;mget key1 key2 nonexisting 1)&quot;hi&quot; //一次获取多个key的值 2)&quot;nihao&quot; 3)(nil) //若key不存在返回nil 2.hash(哈希)redis hash 是一个键值对的集合，是一个string类型的field和value的映射表，适合用于存储对象。 127.0.0.1:6379&gt;hset redishash 1 &quot;001&quot; (integer) 1 127.0.0.1:6379&gt;hget redishash 1 &quot;001&quot; 127.0.0.1:6379&gt;hmset redishash 1 &quot;001&quot; 2 &quot;002&quot; OK 127.0.0.1:6379&gt;hget redishash 1 &quot;001&quot; 127.0.0.1:6379&gt;hget redishash 2 &quot;002&quot; 127.0.0.1:6379&gt;hmget redishash 1 2 1)&quot;001&quot; 2)&quot;002&quot; 3.list(列表)是redis简单的字符串列表，它按插入顺序排序。每一个子元素都是string类型的双向链表。我们可以通过push，pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。 127.0.0.1:6379&gt;lpush word hi (integer)1 //返回1表示成功，0表示key存在且不是list类型 127.0.0.1:6379&gt;lpush word hello (integer)2 127.0.0.1:6379&gt;lpush word world (integer)3 127.0.0.1:6379&gt;lrange word 0 2 1)&quot;hello&quot; 2)&quot;hi&quot; 3)&quot;world&quot; 127.0.0.1:6379&gt;llen word (integer)3 4.set(集合)是string类型的无序集合，不可重复。set元素最大可以包含(2的32次方-1)个元素。set的是通过hash table实现的，hash table会随着添加或者删除自动的调整大小。关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取并集(union)，交集(intersection),差集(difference)。通过这些操作可以很容易的实现sns中的好友推荐和blog的tag功能。 127.0.0.1:6379&gt;sadd redis redisset (integer)1 127.0.0.1:6379&gt;sadd redis redisset1 (integer)1 127.0.0.1:6379&gt;sadd redis redisset2 (integer)1 127.0.0.1:6379&gt;smembers redis 1)&quot;redisset1&quot; 2)&quot;redisset&quot; 3)&quot;redisset2&quot; 127.0.0.1:6379&gt;sadd redis redisset2 (integer)0 127.0.0.1:6379&gt;smembers redis 1)&quot;redisset1&quot; 2)&quot;redisset&quot; 3)&quot;redisset2&quot; 127.0.0.1:6379&gt;srem redis redisset (integer)1 127.0.0.1:6379&gt;smembers redis 1)&quot;redisset1&quot; 2)&quot;redisset2&quot; 5.zset(sorted set 有序集合)是string类型的有序集合，也不可重复sorted set中的每个元素都会关联一个double类型的score。sorted set的实现是skip list 和hash table的混合体。当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，另一个score到元素的映射被添加到skip并按照score排序，所以就可以有序的获取集合中的元素。根据分数对元素进行升序排序，如果多个元素有相同的分数，则以字典顺序进行升序排序，sorted set 因此非常适合实现排名。 127.0.0.1:6379&gt;zadd nosql 0 001 (integer)1 127.0.0.1:6379&gt;zadd nosql 0 002 (integer)1 127.0.0.1:6379&gt;zadd nosql 0 003 (integer)1 127.0.0.1:6379&gt;zcount nosql 0 0 (integer)3 127.0.0.1:6379&gt;zcount nosql 0 3 (integer)3 127.0.0.1:6379&gt;zrem nosql 002 (integer)1 127.0.0.1:6379&gt;zcount nosql 0 3 (integer)2 127.0.0.1:6379&gt;zscore nosql 003 &quot;0&quot; 127.0.0.1:6379&gt;zrangebyscore nosql 0 10 1)&quot;001&quot; 2)&quot;003&quot; 127.0.0.1:6379&gt;zadd nosql 1 003 (integer)0 127.0.0.1:6379&gt;zadd nosql 1 004 (integer)1 127.0.0.1:6379&gt;zrangebyscore nosql 0 10 1)&quot;001&quot; 2)&quot;004&quot; 3)&quot;003&quot; 127.0.0.1:6379&gt;zadd nosql 3 005 (integer)1 127.0.0.1:6379&gt;zadd nosql 2 006 (integer)1 127.0.0.1:6379&gt;zrangebyscore nosql 0 10 1)&quot;001&quot; 2)&quot;003&quot; 3)&quot;004&quot; 4)&quot;006&quot; 5)&quot;005&quot; 5.redis服务相关的命令127.0.0.1:6379&gt;select 0 OK 127.0.0.1:6379&gt;info #Server -------省略N行 select #选择数据库（数据库编号0-15）quit #退出连接info #获得服务的信息与统计monitor #实时监控config get #获得服务配置flushdb #删除当前选择的数据库中的keyflushall #删除所有数据库中的key 6.redis的发布与订阅redis发布与订阅(pub/sub)是它的一种消息通信模式，一方发送消息，一方接受信息。下图是三个客户端同时订阅同一个频道下图是有新信息发送给频道1时。就会将消息发送给订阅它的三个客户端 7.redis持久化redis持久有两种方式:Snapshotting(快照),Append-only file(AOF) Snapshotting(快照) 1、将存储在内存的数据以快照的方式写入二进制文件中，如默认dump.rdb中2、save 900 1 //900秒内如果超过1个Key被修改，则启动快照保存3、save 300 10 //300秒内如果超过10个Key被修改，则启动快照保存4、save 60 10000 //60秒内如果超过10000个Key被修改，则启动快照保存 Append-only file(AOF) 1、使用AOF持久时，服务会将每个收到的写命令通过write函数追加到文件中（appendonly.aof）2、AOF持久化存储方式参数说明appendonly yes //开启AOF持久化存储方式appendfsync always //收到写命令后就立即写入磁盘，效率最差，效果最好appendfsync everysec //每秒写入磁盘一次，效率与效果居中appendfsync no //完全依赖OS，效率最佳，效果没法保证 8.redis性能测试自带相关测试工具 [root@text ~]redis-benchmark --help 实际测试勇士执行100万的请求 [root@text ~]redis-benchmark -n 1000000 -q]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map集合]]></title>
    <url>%2F2018%2F11%2F12%2FMap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Map集合：Hashtable:底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。HashMap:底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。代替了Hashtable。TreeMap:底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。 Map集合存储和Collection有着很大不同：Collection一次存一个元素；Map一次存一对元素。Collection是单列集合；Map是双列集合。Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应（映射）关系。特点：要保证map集合中键的唯一性。 1.添加。 put(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。void putAll(Map);2.删除。void clear()：清空value remove(key) ：删除指定键。3.判断。boolean isEmpty()：boolean containsKey(key)：是否包含keyboolean containsValue(value) ：是否包含value4.取出。int size()：返回长度value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。Collection values()：获取map集合中的所有的值。5.想要获取map中的所有元素：原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。 把map集合转成set的方法： Set keySet(); Set entrySet();//取的是键和值的映射关系。 Entry就是Map接口中的内部接口；为什么要定义在map内部呢?entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。 遍历Map集合的四种方法 public static void main(String[] args){ Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(“1”,”value1”); map.put(“2”,”value2”); map.put(“3”,”value3”); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value: &quot;); for(String key : map.keySet()){ System.out.println(&quot;key=&quot; + key + &quot;and value&quot; + map.get(key)); } } //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value: &quot;); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = map,entrySet().iterator(); while(it.hasNext()){ Map.Entry&lt;String,String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot;and value = &quot; + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for(Map.Entry&lt;String,String&gt; entry : map.entrySet()){ System.out.println(&quot;key= &quot; + entry.getKty() + &quot;and value = &quot; + entey.getValue()); } //第四种 System.out.println(&quot;通过Map.values()遍历所有的value,但布不能遍历key&quot;); for(String v : map.values()){ System.out.println(&quot;value= &quot; + v); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set接口]]></title>
    <url>%2F2018%2F11%2F12%2FSet%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种。迭代器。HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；HashSet集合保证元素唯一性：通过元素的hashCode方法，和Equals方法完成的。当元素的hashCode 值相同时，才继续判断元素的equals是否为true。如果为true，那么视为相同元素，不存。如果为false，那么存储。如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。LinkedHashSet:有序，hashSet的子类。TreeSet:对Set集合中元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。 哈希表的原理：1.对对象元素中的关键字（对象中的特有数据），进行哈希算法的运算，并得出一个具体的算法值，这个值称为哈希值。2.哈希值就是这个元素的位置。3.如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础+1顺延。4.存储哈希值的结构，我们称为哈希表。5.存储哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。 对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。 TreeSet:用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。如果元素不具备比较性，在运行时会发生ClassCastException异常。所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。 注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。 TreeSet集合排序有两种方式，Comparable和Comparator区别：1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。第二种方式较为灵活。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口]]></title>
    <url>%2F2018%2F11%2F12%2FList%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习LIst体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最在的特点。 List:有序（元素存入集合的顺序和取出的顺序一致），元素都有索引。元素可以重复。 ArrayList：底层的数据结构是数组，线程不同步，ArrayList替代了Vector，查询元素的速度非常快。 LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。 Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都很慢。 1.添加：add(index,element) ：在指定的索引位插入元素。addAll(index,collection) ：在指定的索引位插入一堆元素。2.删除：remove(index) ：删除指定索引位的元素。 返回被删的元素。3.获取：Object get(index) ：通过索引获取指定元素。int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回-1；所以，通过-1，可以判断一个元素是否存在。int lastIndexOf(Object o) ：反向索引指定元素的位置。List subList(start,end) ：获取子列表。4.修改：Object set(index,element) ：对指定索引位进行元素的修改。5.获取所有元素：ListIterator listIterator()：list集合特有的迭代器。 List集合支持对元素的增、删、改、查。List集合因为有下标有了自己的获取元素的方式：遍历。 for(int x=0; x&lt;list.size(); x++){ sop(&quot;get:&quot;+list.get(x)); } 注意：在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。导致的原因是：集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。如何解决呢？既然是在迭代中对元素进行操作，找迭代器的方法最为合适。可是Iterator中只有hasNext,next,remove方法。通过查询它的子接口，ListIerator，发现该列表迭代器接口具备了对元素的增、删、改、查的动作。 ListIterator是List集合特有的迭代器。 ListIterator it = list.listIterator;//取代Iterator it = list.iterator; 返回值 方法 void add(E e)将指定的元素插入列表（可选操作）。 boolean hasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。 boolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。 E next() 返回列表中的下一个元素。 int nextIndex() 返回对 next 的后续调用所返回元素的索引。 E previous() 返回列表中的前一个元素。 int previousIndex() 返回对 previous 的后续调用所返回元素的索引。 void remove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。 void set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。 可变长度数组的原理：当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。ArratList：构造一个初始容量为10的空列表。是按照原数组的50%延长（jdk1.8之前为50% + 1）。Vector:是按照原数组的100%延长。 注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。 LinkedList：的特有方法。addFirst();addLast();在jdk1.6以后。offerFirst();offerLast(); getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;getLast();在jdk1.6以后。peekFirst();获取链表中的第一个元素。如果链表为空，返回null。peekLast(); removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementExceptionremoveLast();在jdk1.6以后。pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。pollLast();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Iterator接口]]></title>
    <url>%2F2018%2F11%2F12%2FIterator%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[迭代器：是一个接口。作用：用于取集合中的元素。 返回值 方法 boolean hasNext()如果仍有元素可以迭代，则返回true。 E next()返回迭代的下一个元素。 void remove()从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作） 每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。也就是说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。 Iterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是什么不重要。这对象肯定符合一个规则Iterator接口。 public static void main(String[] args){ Collection coll = new ArrayList(); coll.add(&quot;abc0&quot;); coll.add(&quot;abc1&quot;); coll.add(&quot;abc2&quot;); } //遍历 Iterator it = coll.iterator(); while(it.hasNext()){ System.out.println(it.next()); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection接口]]></title>
    <url>%2F2018%2F11%2F12%2FCollection%2F</url>
    <content type="text"><![CDATA[Collection:List:有序（元素存入集合的顺序和取出的顺序一致），元素都有索引。元素可以重复。Set:无序（存入和取出顺序有可能不一致），不可以存储重复元素。必须保证元素唯一性。1.添加：add(object)：添加一个元素addAll(Collection) ：添加一个集合中的所有元素。2.删除：clear()：将集合中的元素全删除，清空集合。remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。3.判断：boolean contains(obj) ：集合中是否包含指定元素。boolean containsAll(Collection) ：集合中是否包含指定的多个元素。boolean isEmpty()：集合中是否有元素。4.获取：int size()：集合中有几个元素。5.取交集：boolean retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。6.获取集合中所有元素：Iterator iterator()：迭代器7.将集合变成数组：toArray(); 使用集合的技巧：看到Arry就是数组结构，有角标，查询速度很快。看到link就是链表结构，增删速度快，而且有特有方法。addFirst;addLast;removeFirst();removeLast();getFirst();getLast();看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构中的元素必须覆盖hashCode,equals方法。看到tree就是二叉树，就要想到排序，就要用到比较。比较的两种方式：一个是Comparable:覆盖compareTo方法；一个是Comparator:覆盖compare方法。LinkedHashSet,LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。 集合什么时候用？当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。 保证唯一，就用Set。不保证唯一，就用List。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[doGet()与doPost()]]></title>
    <url>%2F2018%2F11%2F10%2FdoGet-%E4%B8%8EdoPost%2F</url>
    <content type="text"><![CDATA[Get与Post都是向服务器传数据在Servlet中doPost方法里还调用了doGet方法(doGet(request,response))所以在创建Servlet时可以不要doPost方法，通常情况下二者没区别。建议：1.涉及传密用Post数据提交。2.数据查询用Get方式；数据添加、修改或删除时，用Post方式。使用表单时，如果不指定method，默认为Get方式。区别： 1.生成方式Get有三种：（1）直接在URL地址栏中输入（2）网页中的超链接（3）form中method为get或不设置methodPost一种：form中method为post 2.数据传输方式Get方式：表单数据存放在URL地址后面。所有Get方式提交时HTTP中没有消息体Post方式：表单数据存放在HTTP协议的消息体中以实体方式传送到服务器。 3.服务器获取数据方式Get方式：服务器采用request.QueryString来获取变量的值。Post方式：服务器采用request.Form来获取数据。 4.传送的数据量Get方式：数据量长度有限制，一般不超过2kb,因为是参数传递，且在地址中，故数据量有限制。Post方式：适合大规模的数据传送，因为是以实体的方式传送的。 5.安全性Get方式：安全性差，因为是直接将数据显示在地址栏中，浏览器有缓冲，可记录用户信息。所以安全性低。Post方式：安全性较高，因为Post方式提交数据时采用的HTTPpost机制，是将表单中的字段与值放置在HTTP HEADER内一起传送到action所指的URL中，用户是看不见的。 6.在用户刷新时Get方式：不会有任何提示Post方式：会弹出提示框，问用户是否重新提交。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet生命周期和创建方式]]></title>
    <url>%2F2018%2F11%2F10%2FServlet-%E4%B8%80-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Servletservlet是运行在Web服务器中的小型Java程序（即，服务器端的小应用程序）。servlet通常通过Http（超文本传输协议）接受和响应来自Web客户端的请求。这个servlet不用new，就是一个Java类，可以直接使用，用来处理请求响应的。写一个Java类实现servlet接口。重写未实现的方法。其实最关键的一个就是service()方法。 Servlet的生命周期（重要）四个过程1.加载和实例化当Servlet容器启动或客户端发送一个请求时，Serlvet容器会查找内存中是否存在该Serlvet实例，若存在，则直接读取该实例响应请求；如果不存在就创建一个Servlet实例。2.init初始化实例化后，Servlet将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）3.service服务，每次被访问都会被调用初始化后，Servlet处于能响应请求的就绪状态。当接受到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求，转调不同的doXXX方法。4.destroy销毁当Servlet容器关闭时，Servlet实例也随时销毁，其间，Servlet容器会调用Servlet的destroy()方法去判断该Servlet是否应当被释放（或回收资源） Servlet执行过程：1.先写一个类实现Servlet接口。2.然后现在web.xml中配置上面第二步中：创建一个servlet实例 &lt;!-- 创建一个Servlet实例 --&gt; &lt;servlet&gt; &lt;!--3.servlet的内部名称--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--4.servlet的类全名：包名加简单类名--&gt; &lt;servlet-class&gt;com.itheima.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; 这个标签其实就是new这个servlet类，底层代码其实就是classforName，因为Tomcat功能可以解析xml，所以可以这么写servlet-mapping: &lt;!-- 给Servlet提供（映射）一个可供客户端访问的URL --&gt; &lt;servlet-mapping&gt; &lt;!--2.servlet的映射内部名称，通过他可以找到上面的servlet的内部名称--&gt; &lt;servlet-name&gt;servletDemo1&lt;/servlet-name&gt; &lt;!--1.请求servlet的映射路径--&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 一定记得加一个/，否则就是访问localhost:8080/demo1，而不是localhost:8080/项目名/demo1，通过这个映射地址找到servlet类。 原理解释： 三步走：1.客户端首先通过地址访问demo下的北荣，tomcat会找到对应的项目。2.然后会通过web.xml找到url-pattern下为 /demo的标签，然后找到兄弟标签servlet-name对应的servletDemo。3.最后找到对应的servlet类，之后就会调用该类下的service()方法。 第一种创建方式：写一个类实现servlet接口，重写5个方法。 import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 第二种创建方式：继承javax.servlet.GenericServlet类（适配器模式），实现service方法 import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; public class ServletDemo2 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } } 第三种创建方式（最常用）：使用方法：创建一个类然后继承HttpServlet类，重写doGet，doPost方法。 import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); } } 对于错误信息： HTTP Status 405 - HTTP method GET is not supported by this URL type Status report message HTTP method GET is not supported by this URL description The specified HTTP method is not allowed for the requested resource. Apache Tomcat/7.0.75 原因是在覆盖doPost或者doGet的时候忘记去掉super.doGet或者super.doPost了，去掉就好了。 补充三种创建方式的关系： Servlet –&gt; GenericServlet –&gt; HttpServlet（继承HttpServlet）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目经验]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[项目名称： 飞机大战项目简介： 该项目主要采用面向对象的思想，通过构建对象实现接口和多线程实时刷新，在JFrame窗体中利用Graphics类在画板上生成和移除，实现了飞机大战的基本玩法，加入了血量，火力升级，积分，敌方飞机的不同轨道以及BOSS独特的攻击模式。 项目名称： 员工管理系统项目简介： 该项目主要采用了Spring,SpringMVC,Mybatis框架和MySQL,JQuery,AJax等为主要技术。项目主要功能为注册，登录进入管理界面，可以对部门、员工进行增删改查，结果利用Page分页显示，利用session记录登录状态，利用cookie实现免登录，验证码利用Graphics生成并添加定时器，提供模糊查找的功能。 项目名称： 饿了么外卖（移动端）项目简介： 该项目采用前后端分离开发，前端主要使用Vue+nginx+node.js。后端主要使用SpringBoot。前端部分展示商家信息，客户评价和商品信息，利用nginx反向代理到本地tomcat服务器。Vue的组件化开发,router实现界面内跳转，整体布局使用弹性布局，利用better-scroll插件实现滚动和联动。后端部分：提供了买家订单，订单详情，商品信息和商品类目的管理。利用SpringBoot生成一个web项目，进行yml的配置，根据Api文档考虑业务逻辑和代码逻辑。例如，买家订单id不能重复，利用系统时间加5位随机数。商品信息和商品类目的展示添加分页，增加和修改可以判断是否有id利用一个页面实现，捕捉异常跳转失败页面，时间的输出格式等。 项目名称： 搭建个人博客项目简述： 该项目是个人利用课余时间摸索搭建而成的个人博客，主要采用node.js,hexo,github为主要技术。项目主要功能为可以上传分享一些文章，展示个人简介，文章归档，标签，分类，归档，站内搜索，评论等功能。并使用个人域名解析实现个性域名。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目简单叙述]]></title>
    <url>%2F2018%2F11%2F08%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%E7%AE%80%E5%8D%95%E5%8F%99%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[项目名： 仿饿了么项目 项目描述： 采用前后端分离开发，前端主要使用Vue+nginx+node.js。后端主要使用SpringBoot。前端部分：展示了商家信息，客户评价和商品信息。利用nginx反向代理到本地tomcat。后端部分：提供了买家订单，订单详情，商品信息和商品类目的管理。 项目实现过程：前端部分：Vue的组件化开发，router路由实现界面跳转，页面布局使用弹性布局。商家信息的背景图片模糊化，公告弹层利用v-show，定位和层级。客户评价获取后台数据。商品信息较为复杂，利用better-scroll插件实现滚动效果和联动。在使用v-for遍历数据时加入index与计算属性绑定实现点击高亮效果。购物车根据商品数量与价格判断是否显示与滚动效果。后端部分：利用springboot生成一个项目，进行yml的配置，根据Api文档考虑业务逻辑和代码逻辑。买家订单id不能重复利用系统时间加5位随机数，根据订单状态判断是否需要取消，商品信息和商品类目的展示添加分页，增加和修改可以判断是否有id利用一个页面实现，捕捉异常跳转失败页面，时间的输出格式等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>springboot</tag>
        <tag>nginx</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math ceil(),floor(),round()方法]]></title>
    <url>%2F2018%2F11%2F07%2FMath-ceil-floor-round-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Math.ceil()对一个数进行向上取整(个人理解向大转)使用方法 Math.ceil(x); 返回值：返回大于或等于x，并且与之最接近的整数。正数则把小数“入”，负数则把小数“舍”。例如： Math.ceil(1.2); //输出2 Math.ceil(1.8); //输出2 Math.ceil(-1.2); //输出-1 Math.ceil(-1.8); //输出-1 Math.floor()对一个数进行向下取整（个人理解向小转）使用方法 Math.floor(x); 返回值：返回小于或等于x并且与之最为接近的整数。正数则把小数“舍”，负数则把小数“入”。例如： Math.floor(1.2); //输出1 Math.floor(1.8); //输出1 Math.floor(-1.2); //输出-2 Math.floor(-1.8); //输出-2 Math.round()四舍五入取整使用方法 Math.round(x); 返回值：与x最接近的整数。 Math.floor(1.2); //输出1 Math.floor(1.8); //输出2 Math.floor(-1.2); //输出-1 Math.floor(-1.8); //输出-2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven远程仓库]]></title>
    <url>%2F2018%2F11%2F05%2FMaven%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Maven配置中央仓库maven作为一个项目管理工具确实为我们提供了很大的方便，但是在国内这个网络下对我们就不是很友好了，阿里云和华为云都为我们提供了中央仓库，个人推荐华为云，因为在学习SpringBoot时，出现了jar包缺少依赖的问题，而华为云没有。 本地仓库在这里先提一下修改本地仓库的储存路径，默认情况下maven会在用户目录下创建.m2/repository/的仓库目录，但一般情况下，我们不希望在C盘有过多的文件，我们需要在找到 \apache-maven\conf\settings.xml 打开，找到settings标签 &lt;settings&gt; //将默认仓库注释掉，添加自定义仓库路径 &lt;localRepository&gt;D:\Program Files\JAVA\mavenRepository&lt;/localRepository&gt; &lt;/settings&gt; 这样maven下载jar包的时候就会下载到自定义路径中 阿里云中央仓库修改远程仓库为阿里云中央仓库 还是在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 这样就配置成功了 华为云中央仓库修改远程仓库为华为云中央仓库 操作差不多，需要多加一步，先在settings.xml配置文件在mirrors标签中添加一个mirror &lt;mirror&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;/url&gt; &lt;/mirror&gt; 还需要在servers标签中添加一个server &lt;servers&gt; &lt;server&gt; &lt;id&gt;huaweicloud&lt;/id&gt; &lt;username&gt;anonymous&lt;/username&gt; &lt;password&gt;devcloud&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 开始体验飞一般的下载速度吧！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的基本使用]]></title>
    <url>%2F2018%2F11%2F03%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git简介Git是目前世界上最先进的分布式版本控制系统。Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。 Git下载https://git-scm.com/downloads一路next就可以在桌面右键出现Git Bash here和Git GUI here就说明成功了 Git基本使用配置用户名，邮箱 git config –global user.email “你的邮箱”git config –global user.name “你的用户名” 这个是用来配置本地仓库的，可以随意填写 创建一个本地版本仓库接下来我们创建第一个仓库1.创建一个空白文件夹，目录不包含中文，右键Git Bash here，输入 git init 我们可以看到当前目录出现了一个.git目录（这是个默认隐藏的文件夹）2.创建一个hellogit.txt文件3.添加文件到本地仓库 git add hellogit.txtgit commit -m “文件描述” 这样我们就把这个文件添加到了本地仓库4.把文件中加一些文字，执行以下命令 git status 查看仓库当前状态，提示有文件被修改了，需要再次执行git add和git commit 版本回退1.打印日志 git log //查看提交历史git reflog //查看命令历史git reset –hard “” //填写你想回退的版本的id 2.查看当前状态 git status 3.删除命令 git rm “文件名”git commit -m “文件描述” 注意：提交到仓库的最好使用命令删除 远程仓库代码托管平台： 码云(gitee.com)：是开源中国社区团队推出的基于Git的快速的、免费的、稳定的在线代码托管平台，不限制私有库和公有库数量。有个缺点是使用page功能时自定义域名需要付费。 github(github.com)：是全球最大的开源社区，基于git的版本托管平台。私有库需要付费，访问速度慢。之前申请的号无故被封，还是得用~ 1.创建SSHkey，以github举例 ssh-keygen -t rsa -C “邮箱” 将此ssh添加到Github的个人设置中的SSH中 ssh -T git@github.com显示Hi，xxxxx就说明成功了 2.创建origin git remote add origin “远程仓库名” //添加远程仓库git remote -v //查看当前绑定仓库git remote remove “远程仓库名” //删除远程仓库 3.向远程仓库推送 git push -u origin mastergit pull origin master //同步远程仓库到本地 4.克隆仓库 git clone “远程仓库名”]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法(Hexo)]]></title>
    <url>%2F2018%2F11%2F02%2FMarkdown%E8%AF%AD%E6%B3%95-Hexo%2F</url>
    <content type="text"><![CDATA[转载：https://blog.csdn.net/zhuzhuyule/article/details/58347687?utm_source=blogxgwz2 Hexo下的Markdown语法Markdown时一种轻量级的标记语言，优点在于： 专注专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明描述分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 **文字** ， __文字__ ， _文字_ ， *文字* ， 文字 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 开头或， 使用`三个反引号 代码内容 三个反引号（Esc下边的键） 链接 [文字](链接地址) 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt; ## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt; ### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt; #### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt; ##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt; ###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 内容强调加粗、斜体字体 **加粗** 显示 字体 *斜体* 显示 字体 ***加粗并斜体*** 显示 字体 __加粗__ 显示 字体 _斜体_ 显示 字体 ___加粗并斜体___ 显示 组合 *__加粗并斜体__* 显示 删除线~~删除一段文本~~ 高亮使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调 比如`突出背景色`来显示强调效果 引用显示标准使用 &gt; 每行开始都使用 &apos;&gt;&apos;； &gt; 引用**开始**； &gt; 引用**换行**； &gt; 引用**结束**。 &gt; 还在引用中！ 两个回车结束引用！ 省略使用 &gt; 仅第一行加应用； 引用开始； 引用换行； 引用结束； 两个回车结束引用,不在引用范围内了！ 表格表格语法： 列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 可以使用冒号来定义对齐方式： | 左对齐 | 右对齐 | 居中 | | :---- | ----:| :--: | 代码块*代码块语法遵循标准 markdown 代码，使用三个反引号开始，三个反引号结束 例如： 1234```JavaSystem.out.println(&quot;Hello World&quot;)``` 特别提示 如何在代码块中打出 三个反引号 实际上是使用 4个` 包含 3个` 就可以了，想表示更多，最外层+1就好了。 1234`````````````` 链接插入[博客]https://www.zwjblog.top 图片插入![我的头像]https://www.zwjblog.top/images/qqtouxiang.jpg 列表无序列表* *列表展示 * *列表展示 * *列表展示 + +列表展示 + +列表展示 + +列表展示 - -列表展示 - -列表展示 - -列表展示 效果如下： *列表展示 *列表展示 *列表展示 +列表展示 +列表展示 +列表展示 -列表展示 -列表展示 -列表展示 有序列表这种方式不用手动设置序号，自动生成列表序列 1. **我是一级序列** 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. *我是二级序列* 1. **我是一级序列** 1. **我是一级序列** 1. *我是二级序列* 1. *我是二级序列* 1. 还是二级序列，没有三级序列 效果如下： 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 我是一级序列 我是一级序列 我是二级序列 //多于一级序列一个空格 我是二级序列 //多于一级序列一个空格 还是二级序列，没有三级序列 // //多于二级序列一个空格，仍然是二级序列 链接自动检测博客：https://www.zwjblog.top]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程的基本理解]]></title>
    <url>%2F2018%2F11%2F02%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[主要参考https://www.cnblogs.com/lwbqqyumidi/p/3804883.html 线程(Thread类)、程序和进程关系：一个程序至少有一个进程，一个进程至少有一个线程。进程是程序在计算机上的一次执行活动，是资源分配的基本单位。线程是调度的基本单位，进程包含线程，线程共用进程的资源。进程是资源分配单位，线程是CPU调度单位。 一、线程的生命周期及五种基本状态这是一张比较经典的图片 Java线程具有五种基本状态新建状态（New）：当线程对象创建后，即进入了新建状态，如 Thread t = new MyThread();就绪状态（Runnable）：当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了start()此线程立即就会执行；运行状态（Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注意：就绪状态是进入到运行状态的唯一入口，也就是说，线程想要进入运行状态执行首先必须处于就绪状态中；阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；2.同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态；3.其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二、Java多项成的创建及启动Java中线程的创建常见有三种基本形式1.继承Thread类，重写该类的run()方法。 class MyThread extends Thread{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest{ public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); if (i == 30){ //创建一个新的线程myThread1此线程进入新建状态 Thread myThread1 = new MyThread(); //创建一个新的线程myThread2此线程进入新建状态 Thread myThread2 = new MyThread(); //调用start()方法使得线程进入就绪状态 myThread1.start(); //调用start()方法使得线程进入就绪状态 myThread2.start(); } } } } 输出的结果： main 0 ~ main 99 Thread-0 0 ~ Thread-0 99 Thread-0 0 ~ Thread-0 99 可以看出虽然当i == 30时，进入判断体，但是线程并没有马上执行，这取决于CPU的调度时机2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实体类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread独享才是真正的线程对象。 class MyRunnable implements Runnable{ private int i = 0; @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } } } public class ThreadTest { public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); } //创建一个Runnable实现类的对象 Runnable myRunnable = new MyRunnable(); //将myRunnable作为Thread target创建新的线程 Thread thread1 = new Thread(myRunnable); //调用start()方法使得线程进入就绪状态 thread1.start(); } } 与实现Runnable接口创建线程方式相似，不同的地方在于 Thread thread = new MyThread(myRunnable); public interface Runnable { public abstract void run(); } @Override public void run() { if (target != null) { target.run(); } } 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; { //.... } public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; { void run(); } 注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat]]></title>
    <url>%2F2018%2F11%2F02%2FSimpleDateFormat%2F</url>
    <content type="text"><![CDATA[SimpleDateFormat的一些常用语法 转自http://www.cnblogs.com/qiangqiangqiang/p/7680752.html SimpleDateFormat函数语法注意大小写 G 年代标志符y 年M 月d 日h 时 在上午或下午 (1~12)H 时 在一天中 (0~23)m 分s 秒S 毫秒E 星期D 一年中的第几天F 一月中第几个星期几w 一年中第几个星期W 一月中第几个星期a 上午 / 下午 标记符k 时 在一天中 (1~24)K 时 在上午或下午 (0~11)z 时区 SimpleDateFormat aDate=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); SimpleDateFormat bDate=new SimpleDateFormat(&quot;yyyy-mmmmmm-dddddd&quot;); long now = System.currentTimeMillis(); 运行结果： 2018-11-02 14:40:482018-000040-000002 SimpleDateFormat myFmt=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); SimpleDateFormat myFmt1=new SimpleDateFormat(&quot;yy/MM/dd HH:mm&quot;); SimpleDateFormat myFmt2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//等价于now.toLocaleString() SimpleDateFormat myFmt3=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;); SimpleDateFormat myFmt4=new SimpleDateFormat( &quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;); 运行结果： 2018-11-02 14:41:552018-000041-0000022018年11月02日 14时41分55秒18/11/02 14:412018-11-02 14:41:552018年11月02日 14时41分55秒 星期五一年中的第 306 天 一年中第44个星期 一月中第1个星期 在一天中14时 CST时区 笔试题：求10天后的时间，并以”yyyy年MM月dd日”格式输出 import java.text.SimpleDateFormat; public class Test { public static void main(String[] args) { //格式化日期 SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //当前系统时间加上10天的时间，单位（毫秒） long tenday = System.currentTimeMillis() + 10 * 24 * 60 * 60 * 1000; //输出 System.out.println(date.format(tenday)); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么项目SpringBoot]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AESpringBoot%2F</url>
    <content type="text"><![CDATA[前端部分后补充 后端部分摘自老师的笔记 一、环境搭建和工具 所需环境：java,mysql,tomcat 使用工具：IDEA,Navicat 二、数据库的设计表设计 类目create table `product_category` ( `category_id` int not null auto_increment, `category_name` varchar(64) not null comment &apos;类目名字&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`category_id`) ); 商品create table `product_info` ( `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;单价&apos;, `product_stock` int not null comment &apos;库存&apos;, `product_description` varchar(64) comment &apos;描述&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `product_status` tinyint(3) DEFAULT &apos;0&apos; COMMENT &apos;商品状态,0正常1下架&apos;, `category_type` int not null comment &apos;类目编号&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`product_id`) ); 订单create table `order_master` ( `order_id` varchar(32) not null, `buyer_name` varchar(32) not null comment &apos;买家名字&apos;, `buyer_phone` varchar(32) not null comment &apos;买家电话&apos;, `buyer_address` varchar(128) not null comment &apos;买家地址&apos;, `buyer_openid` varchar(64) not null comment &apos;买家微信openid&apos;, `order_amount` decimal(8,2) not null comment &apos;订单总金额&apos;, `order_status` tinyint(3) not null default &apos;0&apos; comment &apos;订单状态, 默认为新下单&apos;, `pay_status` tinyint(3) not null default &apos;0&apos; comment &apos;支付状态, 默认未支付&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`order_id`), key `idx_buyer_openid` (`buyer_openid`) ); 订单商品create table `order_detail` ( `detail_id` varchar(32) not null, `order_id` varchar(32) not null, `product_id` varchar(32) not null, `product_name` varchar(64) not null comment &apos;商品名称&apos;, `product_price` decimal(8,2) not null comment &apos;当前价格,单位分&apos;, `product_quantity` int not null comment &apos;数量&apos;, `product_icon` varchar(512) comment &apos;小图&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`detail_id`), key `idx_order_id` (`order_id`) ); 卖家create table `seller_info` ( `id` varchar(32) not null, `username` varchar(32) not null, `password` varchar(32) not null, `openid` varchar(64) not null comment &apos;微信openid&apos;, `create_time` timestamp not null default current_timestamp comment &apos;创建时间&apos;, `update_time` timestamp not null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;, primary key (`id`) ) comment &apos;卖家信息表&apos;; 三、Api文档商品列表 GET /sell/buyer/product/list 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;name&quot;: &quot;热榜&quot;, &quot;type&quot;: 1, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;皮蛋粥&quot;, &quot;price&quot;: 1.2, &quot;description&quot;: &quot;好吃的皮蛋粥&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] }, { &quot;name&quot;: &quot;好吃的&quot;, &quot;type&quot;: 2, &quot;foods&quot;: [ { &quot;id&quot;: &quot;123457&quot;, &quot;name&quot;: &quot;蛋糕&quot;, &quot;price&quot;: 10.9, &quot;description&quot;: &quot;美味爽口&quot;, &quot;icon&quot;: &quot;http://xxx.com&quot;, } ] } ] } 创建订单 POST /sell/buyer/order/create 参数 name: &quot;张三&quot; phone: &quot;13333333333&quot; address: &quot;西七道&quot; openid: &quot;ew3euwhd7sjw9diwkq&quot; //用户的微信openid items: [{ productId: &quot;1423113435324&quot;, productQuantity: 2 //购买数量 }] 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;147283992738221&quot; } } 订单列表 GET /sell/buyer/order/list 参数 openid: 18eu2jwk2kse3r42e2e page: 0 //从第0页开始 size: 10 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ { &quot;orderId&quot;: &quot;161873371171128075&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }, { &quot;orderId&quot;: &quot;161873371171128076&quot;, &quot;buyerName&quot;: &quot;张三&quot;, &quot;buyerPhone&quot;: &quot;13333333333&quot;, &quot;buyerAddress&quot;: &quot;西七道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 0, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490171219, &quot;updateTime&quot;: 1490171219, &quot;orderDetailList&quot;: null }] } 查询订单详情 GET /sell/buyer/order/detail 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: { &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;buyerName&quot;: &quot;李四&quot;, &quot;buyerPhone&quot;: &quot;15555555555&quot;, &quot;buyerAddress&quot;: &quot;西八道&quot;, &quot;buyerOpenid&quot;: &quot;18eu2jwk2kse3r42e2e&quot;, &quot;orderAmount&quot;: 18, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: 1490177352, &quot;updateTime&quot;: 1490177352, &quot;orderDetailList&quot;: [ { &quot;detailId&quot;: &quot;161899085974995851&quot;, &quot;orderId&quot;: &quot;161899085773669363&quot;, &quot;productId&quot;: &quot;157875196362360019&quot;, &quot;productName&quot;: &quot;招牌奶茶&quot;, &quot;productPrice&quot;: 9, &quot;productQuantity&quot;: 2, &quot;productIcon&quot;: &quot;http://xxx.com&quot;, &quot;productImage&quot;: &quot;http://xxx.com&quot; } ] } } 取消订单 POST /sell/buyer/order/cancel 参数 openid: 18eu2jwk2kse3r42e2e orderId: 161899085773669363 返回 { &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: null } 获取openid 重定向到 /sell/wechat/authorize 参数 returnUrl: http://xxx.com/abc //【必填】 返回 http://xxx.com/abc?openid=oZxSYw5ldcxv6H0EU67GgSXOUrVg 支付订单 重定向 /sell/pay/create 参数 orderId: 161899085773669363 returnUrl: http://xxx.com/abc/order/161899085773669363 返回 http://xxx.com/abc/order/161899085773669363 四、买家类目1.dao层需要的方法根据categoryType的集合来查询 2.service需要的方法根据id查询查询所有根据categoryType的集合来查询新增和更新 五、商品1.dao层需要的方法根据商品状态来查询 2.service层需要的方法根据id查询查询所有上架商品查询所有商品（给管理端使用，需要包含分页）增加和修改方法 3.买家端API的开发提供一个查询所有商品和类别的api接口（需要重新包装数据）]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>springboot</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F10%2F29%2Fspringboot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringBoot项目的构建有三种方式：一、手动构建利用maven构建一个普通的项目，我们手动去加入依赖。 1.在pom中引入父pom,代码如下&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.17.RELEASE&lt;/version&gt; &lt;/parent&gt; 2.引入SpringBoot依赖，代码如下&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3.加入编译插件&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 4.写一个启动类@Controller //可以帮助SpringBoot应用将所有符合条件的@Configuration配置 都加载到当前SpringBoot创建并使用的IoC容器。 @EnableAutoConfiguration public class BootStarter { //servlet映射地址 @RequestMapping(&quot;/hello&quot;) //返回json格式的数据 @ResponseBody public String hello(){ return &quot;hello world&quot;; } public static void main(String[] args) { // SpringApplication.run(BootStarter.class,args); } } 5.运行main方法，在地址栏访问localhost:8080/hello . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \ ( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.17.RELEASE) 启动成功！ 二、Spring官网Spring官网为我们提供了生成项目的方式访问https://start.spring.io/根据提示填写，下载解压使用IDEA将项目打开 三、利用IDEA工具新建项目直接选择Spring Initializr就可以生成一个Spring Boot项目（常用）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于node.js,hexo,github搭建博客]]></title>
    <url>%2F2018%2F10%2F29%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[基于 node.js+hexo+github 搭建一个属于自己的博客！ 前言&emsp;&emsp;从买阿里云服务器开始说起，开始研究服务器到底能做什么，最开始了解到云服务器可以是一台24小时运行的电脑，并且拥有自己的IP，就想着先把做的仿饿了么外卖项目放到服务器上运行，经过无数的踩坑，从linux系统都不会进到后面的关防火墙，配置安全组。再到搭建Node.js环境，git环境，连接github，终于让项目跑起来。再开始想怎样实现员工管理系统也能在服务器上运行，又开始配置JDK，Mysql，Tomcat环境，最后几经周折也实现了（虽然还有）一些BUG。 &emsp;&emsp;通过阿里云，又了解了域名相关，就想着自己是不是可以拥有一个属于自己的域名，比如说自定义的博客，也可以在服务器上跑（不能让它闲着–！），就开始在网上搜寻相关的知识。开始真的是一头雾水，别人是一步一个脚印，我感觉我是一步一个坑，最后摸索出用node.js+hexo+github 就可以实现我想要的结果，不容易不容易。 正题配置环境我们需要配置所需要的工具node.js+hexo+github这里就暂时不做过多解释，只给出检测的方法。在一个空文件夹下，右键Git Bash here node -version npm -version git -version 都能显示版本说明我们可以开始搭建了。 hexo初始化我们需要一个官方默认的hexo主题，在Git界面执行以下命令 hexo init 这是遇到的一个大坑，几KB每秒的下载速度，最后还卡住了，果断扔到服务器上下载。我上传到百度网盘，可以下载，下载后不需要执行上面的代码。 链接：https://pan.baidu.com/s/1QZSevQU6zkvJ55DnFUWQMQ提取码：m67r 接下来我们需要配置hexo和node依赖的包 npm install 这时我们可以查看hexo是否初始化 hexo -version 显示版本就说明hexo可以使用。 git部分git这部分，我们需要将此文件夹下的文件利用下面的代码先推到git中 git init git add -A git commit -m &quot;提交&quot; git remote add origin &quot;你的github仓库&quot; 这里需要注意的是：不要往仓库上推，仓库存的不是这部分文件，而是一些静态资源文件，比如html、css和js文件。 hexo主题生成清理静态资源文件 hexo clean 生成静态资源文件 hexo g 部署项目，通过localhost:4000访问 hexo s 页面出现Hexo，此时就说明成功了&emsp;&emsp;接下来的就比较简单了，打开hexo下的_config.yml文件，这个文件包含了hexo的站点配置，在最下方需要添加代码 deploy: type: git repo: &quot;这里填写你的github仓库&quot; branch: master &emsp;&emsp;这个时候千万不要用git pull或者git push等命令！应该使用 hexo clean hexo g hexo d hexo d这个命令就可以把你的项目提交到你的github仓库中。 github网址生成&emsp;&emsp;github对我们很友好（吐槽下真的很慢），为我们提供了一个功能，生成了一个网址可以展示仓库中的项目，但这个功能需要手动开启，打开我们的github，找到对应的仓库，找到Setting选项下的GitHub Pages，选择Source中你项目的分支，一般是主分支。实在不行开个翻译，很好找，点击保存后，这样就会显示一个网址，这样就可以访问了。注意：项目名需要xxx.github.io的格式，还需要在_config.yml中找到以下代码。 url: &quot;你生成的网址&quot; root: /项目名 结束语&emsp;&emsp;仔细回想一下，其实挺简单的，主要是什么都不知道，还有没想到的以后再进行补充，欢迎留言评论。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
